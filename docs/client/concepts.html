<template name="concepts">

<h1 id="concetti">Concetti di base</h1>

Fino ad oggi abbiamo scritto le nostre SPA (Single Page Application) in
JavaScript a mano. Scrivere un'intera applicazione in un solo
linguaggio (JavaScript) con un solo formato dati (JSON) è fantastico.
Meteor è tutto ciò che avremmo voluto per scrivere queste applicazioni.

{{> whatismeteor }}
{{> structure }}
{{> data }}
{{> reactivity }}
{{> livehtml }}
{{> templates }}
{{> packages_concept }}
{{> namespacing }}
{{> deploying }}
{{> packages_writing }}
</template>

<template name="whatismeteor">

{{#better_markdown}}

<h2 id="cosmeteor">Cos'è Meteor?</h2>

Meteor è due cose:

* Una _libreria di package_: moduli già scritti ed indipendenti che puoi
utilizzare nell'applicazione.<br>
Esitono una dozzina circa di package core in Meteor utilizzati da
praticamente tutte le app (ad esempio `webapp`, che gestisce le
connessioni HTTP, o `templating`, che permette di scrivere template
HTML che si aggiornano automaticamente quando i dati cambiano).
Poi ci sono packages opzionali come `email`, per spedire email, o il
gruppo dei Meteor Accounts (`account-password`, `accounts-facebook`,
`account-ui`, e altri) che fornisce un completo sistema di gestione
utenti pronto all'uso. Oltre a questi package "ufficiali" ce ne sono
centinaia scritti dalla comunità in [Atmosphere](https://atmosphere.meteor.com/),
che potrebbero già fare esattamente ciò che serve.

* Una _applicazione a linea di comando_ chiamata `meteor`.<br>
`meteor` è un'applicazione simile a `make`, `rake`, oppure ai tool non
visuali di Visual Studio. Mette insieme tutti i file sorgenti e gli
asset dell'applicazione, esegue tutti i passi necessari a costruirla
(come compilare [CoffeeScript](http://coffeescript.org), minimizzare i
CSS, costruire i moduli [npm](https://npmjs.org/), o generare le source
map), installa i packages usati nell'app, e produce il bundle
dell'applicazione pronto per essere eseguito. Durante lo sviluppo fa
tutto ciò in maniera interattiva ed automatica, così che le modifiche ai
file si riflettono direttamente nel browser che esegue l'applicazione.
E' semplicissimo da usare senza configurazione, ma è anche
personalizzabile: si può aggiungere il supporto per nuovi linguaggi ed
interpreti aggiungendo package compilatori all'app.

L'idea di base nel sistema di package di Meteor è che _ogni cosa
dovrebbe funzionare allo stesso modo nel browser e sul server_
(naturalmente se ha senso che lo faccia: i browser non possono spedire
email ed il server non può gestire gli eventi del mouse). Tutto
l'ecosistema è stato costruito per supportare questo principio.

{{#note}}
`meteor` non può installare package da Atmosphere. Se si utilizzano
package di Atmosphere bisogna usare [Meteorite](http://oortcloud.github.io/meteorite/),
un'applicazione che gestisce ed installa i package di Atmosphere.

In Meteor 1.0, `meteor` incorporerà il pieno supporto ad Atmosphere.
{{/note}}

{{/better_markdown}}
</template>

<template name="structure">
{{#better_markdown}}

<h2 id="strutturadiunapp">Struttura di una applicazione</h2>

Una applicazione Meteor è un mix di JavaScript eseguito nel browser,
JavaScript eseguito dal server di Meteor in un'istanza di [Node.js](http://nodejs.org),
più tutto l'HTML di supporto, regole CSS e asset statici (immagini, icone,
fonts...). Meteor automatizza la gestione e l'assemblaggio di questi
componenti. Inoltre lascia un buon grado di libertà sull'organizzazione
di file e cartelle che contengono questi componenti.

Lato server vengono visti solo i file JavaScript ed i file contenuti
nella cartella `private`. Meteor raggruppa tutti i file
JavaScript, esclusi quelli nelle cartelle `client`, `public` e
`private` e li serve ad una istanza di Node.js in una fiber. In Meteor,
il codice server-side viene eseguito in un singolo thread per richiesta,
non come callback asincrona tipica di Node. Abbiamo scelto il modello
di esecuzione lineare sincrono perchè ci sembra più adatto per il
codice server di una applicazione Meteor.

Tutti i file nella cartella `private` sono resi disponibili al
solo codice server attraverso l'API [`Assets`](#assets). La cartella
`private` deve essere usata per conservare i file accessibili al codice
server side ma che non devono essere trasferiti al client, cioè i dati
privati, appunto.

Lato client vengono gestite anche altre risorse. Meteor mette insieme
e rende disponibili al client tutti i file del progetto ad
esclusione delle cartelle `server`, `public` e `private`.
I file vengono compressi e trasferiti ad ogni client. Si è liberi di
usare un unico file JavaScript per l'intera applicazione o creare una
struttura ad albero di file singoli, o una via di mezzo. 

Alcune librerie JavaScript funzionano solo se messe in
`client/compatibility`. I file in questa cartella sono eseguiti senza
essere inglobati nello scope di una nuova variabile. Significa che ogni
`var` non locale definisce una variabile globale. Inoltre questi file
vengono eseguiti prima degli altri file JavaScript client side.

Il file esterni alle cartelle `client`, `server` e `tests` vengono
caricati sia sul client che sul server! E' dove possiamo definire la
nostra base dati (il modello) e le altre funzioni. Meteor permette di
consultare le variabili [`isClient`](#meteor_isclient) e [`isServer`](#meteor_isserver)
per eseguire codice solo lato client o solo lato server. (I file della
cartella `tests` non vengono caricati da nessuna parte.)

Tutto il codice riservato che non si vuole rendere visibile lato
client, come il codice che contiene password o meccanismi di
autenticazione, dovrebbe stare nella cartella `server`.

Anche i file CSS sono raggruppati insieme: il client riceverà un unico
file con tutti i CSS (esclusi quelli eventualmente contenuti nelle
cartelle `server`, `public` e `private`).

In modalità debug i file JavaScript e CSS sono inviati divisi per
rendere il debug più semplice.

I file HTML in Meteor sono gestiti diversamente dagli altri framework
server-side. Meteor legge tutti i file HTML alla ricerca degli elementi
`<head>`, `<body>` e `<template>` nella radice della struttura.
Le sezioni head e body sono unite in un unico file trasmesso al client
al momento del caricamenteo iniziale dell'applicazione.

Le sezioni template invece sono convertite in funzioni JavaScript
disponibili nel namespace `Template`. E' un modo molto efficiente di
fornire i template HTML al client.
Si può consultare la sezione [templates](#templates) per ulteriori
dettagli.

Infine il server Meteor rende disponibili i file nella cartella `public`
allo stesso modo dei framework Rails o Django. Qui mettiamo le
immagini, `favicon.ico`, `robots.txt` e tutto il resto.

E' buona norma scrivere la nostra applicaziome in modo che sia
indipendente dall'ordine con cui i file vengono caricati, ad esempio
usando [Meteor.startup](#meteor_startup), o spostando il codice che
dipende da un particolare ordine di caricamento nei [packages](#usingpackages)
dove si può esplicitamente controllare l'ordine di caricamento del
proprio contenuto e dello stesso package rispetto agli altri.
Ciò nonostante a volte è impossibile evitare di dipendere da un preciso ordine
di caricamento. I file JavaScript e CSS vengono caricati seguendo queste regole:

* I file nelle sottodirectory vengono caricati prima dei file presenti nelle
  directory padre, quindi i file nelle subdirectory più annidate sono i primi ad
  essere caricati, mentre quelli nella directory principale sono gli ultimi.

* Nella stessa cartella i file sono caricati in ordine alfabetico.

* Dopo il riordino sopra descritto, tutti i file nella directory `lib` vengono
  caricati prima di tutti gli altri (preservando il loro ordine).

* Infine tutti i file denominati `main.*` vengono caricati dopo tutti gli altri
  (preservando il loro ordine).

{{/better_markdown}}
</template>

<template name="data">
{{#better_markdown}}

<h2 id="datiesicurezza">Dati e sicurezza</h2>

Meteor rende la scrittura di codice lato client semplice perchè si
interfaccia sempre con un database locale. E’ un approccio
semplice, pulito e sicuro che ci risparmia di dover implementare Remote
Procedure Call, di mantenere manualmente una cache sul client (che evita
lente consultazioni al server) e di impegnarsi nella faticosa gestione
della sincronizzazione di tutti i client quando i dati cambiano.

In Meteor, il client ed il server condividono le stesse API per
l’accesso al database. Lo stesso codice &mdash; per la validazione e
l'elaborazione dei dati &mdash; può spesso girare su entrambi i lati.
La differenza è che il codice che gira lato server ha accesso diretto
al database, quello lato client *no*. Su questa distinzione si fonda il
modello di sicurezza dei dati in Meteor.

{{#note}}
Per default una nuova applicazione Meteor include i packages
`autopublish` e `insecure`, che insieme permettono ad ogni client di
avere accesso completo in lettura/scrittura al database sul server.
Sono strumenti utili in fase di prototipizzazione dell’applicazione,
ma ovviamente non adatti al prodotto finale. Quando è il momento, basta
rimuovere questi packages.
{{/note}}

Con Meteor ogni client possiede un database in memoria. Per gestire
questa cache lato client, il server *pubblica* set di documenti JSON,
ed il client *sottoscrive* questi set. Quando i documenti in un
set cambiano, il server aggiorna le cache di tutti i client.

Ad oggi la maggior parte delle applicazioni sviluppate con Meteor usa
MongoDB perchè è quello meglio supportato, ma è già previsto in futuro
il supporto per altri database. La classe [Meteor.Collection](http://docs.meteor.com/#meteor_collection)
è utilizzata per dichiarare collezioni in Mongo e manipolarle. Grazie a
`minimongo`, l’emulatore di Mongo che gira nel browser,
`Meteor.Collection` può essere usata sia lato client che server.

    // declare collections
    // this code should be included in both the client and the server
    Rooms = new Meteor.Collection("rooms");
    Messages = new Meteor.Collection("messages");
    Parties = new Meteor.Collection("parties");

    // server: populate collections with some initial documents
    Rooms.insert({name: "Conference Room A"});
    var myRooms = Rooms.find({}).fetch();
    Messages.insert({text: "Hello world", room: myRooms[0]._id});
    Parties.insert({name: "Super Bowl Party"});

Ogni set di documenti è definito da una funzione di pubblicazione
sul server. La funzione di pubblicazione viene eseguita ogni volta che
un nuovo client sottoscrive quel set di documenti. I dati che
compongono un set di documenti possono provenire da qualsiasi fonte, ma
la cosa più probabile è che provengano da una query sul database.

    // server: publish all room documents
    Meteor.publish("all-rooms", function () {
      return Rooms.find(); // everything
    });

    // server: publish all messages for a given room
    Meteor.publish("messages", function (roomId) {
      check(roomId, String);
      return Messages.find({room: roomId});
    });

    // server: publish the set of parties the logged-in user can see.
    Meteor.publish("parties", function () {
      return Parties.find({$or: [{"public": true},
                                 {invited: this.userId},
                                 {owner: this.userId}]});
    });

Le funzioni di pubblicazione possono fornire risultati diversi per ogni
client. Nell’esempio sopra un utente loggato può vedere solo documenti
della collezione `Parties` che sono pubblici, che l’utente possiede o a
cui l’utente è stato invitato.

Una volta sottoscritto, il client usa la sua cache come un veloce
database locale, semplificando enormemente il codice lato client. Le
operazioni di lettura non richiedono mai una lenta richiesta al server.
Inoltre sono limitate al contenuto della cache: sul client una query su
tutti i documenti restituirà solo i documenti che il server ha
pubblicato per quel client.

    // client: start a parties subscription
    Meteor.subscribe("parties");

    // client: return array of Parties this client can read
    return Parties.find().fetch(); // synchronous!

Dal lato client possiamo poi decidere di attivare e disattivare le
sottoscrizioni per regolare la quantità di dati mantenuta nella cache e
gestire al meglio il traffico sulla rete. Quando una sottoscrizione
viene disattivata, tutti i suoi documenti sono rimossi dalla cache, a
meno che lo stesso documento non venga fornito da un’altra
sottoscrizione attiva.

Quando il client *cambia* uno o più documenti manda un messaggio al
server per memorizzare la variazione. Il server verifica i cambiamenti
proposti tenendo conto di una serie di regole permetti/nega che lo
sviluppatore ha scritto sotto forma di funzioni Javascript. A questo
punto il server accetta i cambiamenti se tutte le regole sono
rispettate.

    // server: don't allow client to insert a party
    Parties.allow({
      insert: function (userId, party) {
        return false;
      }
    });

    // client: this will fail
    var party = { ... };
    Parties.insert(party);

Se il server accetta le modifiche, le applica al database e
automaticamente le propaga a tutti i client che hanno sottoscritto i
documenti modificati. Se non le accetta, l’aggiornamento fallisce, il
database rimane inalterato e nessun client vede le modifiche.

Sveliamo ora che Meteor si serve di un trucco. Quando un client scrive
qualcosa nel database, la cache nel client viene aggiornata
immediatamente senza attendere la risposta del server. In questo modo
l'utente riceve immediato feedback di esecuzione della scrittura. Se
successivamente il server valida ed accetta la modifica &mdash; ed è
ciò che dovrebbe accadere nella maggioranza dei casi &mdash; il client
non necessita di ulteriore aggiornamento della schermata. Se invece il
server annulla la modifica, Meteor risincronizza la cache del client
con i dati del server.

Tutto ciò in sostanza realizza la compensazione della latenza. I
client hanno sempre una copia aggiornata dei dati e non hanno mai
bisogno di attendere il server. Quando i client modificano i dati,
le modifiche vengono immediatamente memorizzate senza attendere la
conferma dal server, pur dando a quest'ultimo l'ultima parola sulla
validità delle modifiche stesse.

{{#note}}
L'attuale release di Meteor supporta MongoDB, il famoso database basato
su documenti, e gli esempi usano le [MongoDB API](http://www.mongodb.org/display/DOCS/Manual).
Le future versioni avranno il supporto per altri database.
{{/note}}

<h3 id="dataandsecurity-authentication">Autenticazione e gestione utenti</h3>

Meteor include un sistema di autenticazione all'avanguardia: [Meteor
Accounts](#account_api). Prevede la gestione dei login con password
tramite [Secure Remote Password control](http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol),
oppure attraverso l'integrazione con servizi esterni come Facebook,
GitHub, Google, Meetup, Twitter e Weibo. Meteor Accounts crea una
collezione [`Meteor.users`](#meteor_users) dove possono essere
memorizzati i dati utente specifici dell'applicazione.

Meteor inoltre fornisce form gia predisposte per le attività più comuni
come login, sottoscrizione, cambio password e reset della password
tramite email. Per averle basta aggiungere [Accounts UI](#accountsui)
con una sola riga di comando. Il package `accounts-ui` fornisce anche un
wizard di configurazione per impostare l'uso dei servizi esterni di
login nella propria applicazione.

<h3 id="dataandsecurity-validation">Validazione dell'input</h3>

Meteor consente di usare argomenti di tipo [JSON](http://json.org) per i metodi
e le funzioni di pubblicazione (in realtà, il protocollo di comunicazione di
Meteor supporta [EJSON](#ejson), una estensione di JSON che supporta anche
altri tipi di dati comuni, come date e buffer binari.) Sebbene JavaScript
faccia uso di tipi di dato dinamici che evitano di dover dichiarare l'esatto
tipo di ogni variabile utilizzata, è tuttavia utile assicurarsi che gli
argomenti passati dal client ai metodi ed alle funzioni di pubblicazione
siano esattamente del tipo atteso.

Meteor fornisce una [mini libreria](#match) per controllare che gli argomenti
e gli altri valori siano del tipo atteso. Basta invocare dei controlli del
tipo `check(username, String)` oppure `check(office, {building: String, room: Number})`
prima di chiamare ogni funzione. La chiamata a `check` produrrà un errore se
l'argomento passato non è del tipo specificato.

Meteor fornisce anche un metodo veloce per accertarsi che tutti i metodi e le
funzioni di pubblicazione facciano la validazione di tutti gli argomenti. Basta
aggiungere il package <code>meteor add [audit-argument-checks](#auditargumentchecks)</code> :
tutti i metodi e le funzioni di pubblicazione che non fanno il `check`ing
produrranno un'eccezione.

{{/better_markdown}}
</template>

<template name="reactivity">
{{#better_markdown}}

<h2 id="reattivit">Reattività</h2>

Meteor sposa il concetto di [reactive programming](http://en.wikipedia.org/wiki/Reactive_programming).
Significa che il codice può essere scritto in semplice stile imperativo ma
verrà rieseguito automaticamente ogni volta che i dati da cui dipende saranno
modificati.

    Deps.autorun(function () {
      Meteor.subscribe("messages", Session.get("currentRoomId"));
    });

Questo esempio (preso dal client di una chat room) sottoscrive dei dati in base
al valore della variabile di sessione `currentRoomId`. Se il valore di
`Session.get("currentRoomId")` cambia per qualsiasi motivo la funzione sarà
automaticamente rieseguita, ed una nuova sottoscrizione andrà a sostituire la
precedente.

Questo aggiornamento automatico si ottiene attraverso la cooperazione tra
`Session` e `Deps.autorun`. `Deps.autorun` decide quando eseguire una
"elaborazione reattiva" delle funzioni passate come argomento, cioè al variare
dei dati da cui ogni funzione dipende. I dati, come ad esempio quelli forniti
dall'oggetto `Session`, sanno quale codice li monitorizza e si occupano di
segnalare a quel codice che sono cambiati ed è quindi necessaria una nuova
elaborazione.

Questo schema di funzionamento (esecuzione reattiva + sorgente dati reattiva) ha
grandi benefici. Nell'esempio sopra, il programmatore non si deve preoccupare di
scrivere il codice che ri-sottoscrive al momento opportuno i dati aggiornati.
Meteor permette quindi di eliminare il codice che si occupa di tenere traccia
delle modifiche ai dati che finirebbe per intasare l'applicazione con la
conseguenza di introdurre bug.

Queste funzioni in Meteor permettono di scrivere codice che sarà eseguito in
maniera reattiva:

* [Templates](#templates)
* [`Meteor.render`](#meteor_render) e [`Meteor.renderList`](#meteor_renderlist)
* [`Deps.autorun`](#deps_autorun)

Mentre le sorgenti dati reattive che possono scatenare la riesecuzione sono:

* Le variabili memorizzate in [`Session`](#session)
* Query sulle [Collections](#find) del database
* [`Meteor.status`](#meteor_status)
* Il metodo `ready()` su un [subscription handle](#meteor_subscribe)
* [`Meteor.user`](#meteor_user)
* [`Meteor.userId`](#meteor_userid)
* [`Meteor.loggingIn`](#meteor_loggingin)

Inoltre le seguenti funzioni che ritornano un oggetto con un metodo
`stop`, vengono interrote quando il ricalcolo viene eseguito o fermato, se
usate nel codice ad esecuzione reattiva.

* [`Deps.autorun`](#deps_autorun) (annidata)
* [`Meteor.subscribe`](#meteor_subscribe)
* [`observe()`](#observe) e [`observeChanges()`](#observe_changes) sui cursori

Tutto ciò in Meteor è
[implementato](https://github.com/meteor/meteor/blob/master/packages/deps/deps.js)
in un package chiamato [`Deps`](#deps) piuttosto piccolo e facilmente
comprensibile. Lo si può usare per implementare nuove sorgenti dati reattive.

{{/better_markdown}}
</template>

<template name="livehtml">
{{#better_markdown}}

<h2 id="livehtml">Live HTML</h2>

HTML templating is central to web applications. With Meteor's live
page update technology, you can render your HTML _reactively_, meaning
that it will update automatically to track changes in the data used to
generate it.

This optional feature works with any HTML templating library, or even
with HTML you generate manually from JavaScript. Here's an example:

    var fragment = Meteor.render(
      function () {
        var name = Session.get("name") || "Anonymous";
        return "<div>Hello, " + name + "</div>";
      });
    document.body.appendChild(fragment);

    Session.set("name", "Bob"); // page updates automatically!

[`Meteor.render`](#meteor_render) takes a rendering function, that is, a
function that returns some HTML as a string. It returns an auto-updating
`DocumentFragment`. When there is a change to data used by the rendering
function, it is re-run. The DOM nodes in the `DocumentFragment` then
update themselves in-place, no matter where they were inserted on the
page. It's completely automatic. [`Meteor.render`](#meteor_render) uses
a [reactive computation](#reactivity) to discover what data is used by the
rendering function.

Most of the time, though, you won't call these functions directly
&mdash; you'll just use your favorite templating package, such as
Handlebars or Jade. The `render` and `renderList` functions are intended
for people that are implementing new templating systems.

Meteor normally batches up any needed updates and executes them only
when your code isn't running. That way, you can be sure that the DOM
won't change out from underneath you. Sometimes you want the opposite
behavior. For example, if you've just inserted a record in the
database, you might want to force the DOM to update so you can find
the new elements using a library like jQuery. In that case, call
[`Deps.flush`](#deps_flush) to bring the DOM up to date
immediately.

When live-updating DOM elements are taken off the screen, they are automatically
cleaned up &mdash; their callbacks are torn down, any associated database
queries are stopped, and they stop updating. For this reason, you never have to
worry about the [zombie
templates](http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/)
that plague hand-written update logic. To protect your elements from cleanup,
just make sure that they are on-screen before your code returns to the event loop,
or before any call you make to [`Deps.flush`](#deps_flush).

Another thorny problem in hand-written applications is element
preservation. Suppose the user is typing text into an `<input>`
element, and then the area of the page that includes that element is
redrawn. The user could be in for a bumpy ride, as the focus, the
cursor position, the partially entered text, and the accented
character input state will be lost when the `<input>` is recreated.

This is another problem that Meteor solves for you. You can specify
elements to preserve when templates are re-rendered with the
[`preserve`](#template_preserve) directive on the template. Meteor will
preserve these elements even when their enclosing template is
rerendered, but will still update their children and copy over any
attribute changes.

{{/better_markdown}}
</template>

<template name="templates">
{{#better_markdown}}

<h2 id="templates">Templates</h2>

Meteor makes it easy to use your favorite HTML templating language,
such as Handlebars or Jade, along with Meteor's live page update
technology. Just write your template as you normally would, and Meteor
will take care of making it update in realtime.

To use this feature, create a file in your project with the `.html`
extension. In the file, make a `<template>` tag and give it a
`name` attribute. Put the template contents inside the tag. Meteor
will precompile the template, ship it down to the client, and make it
available as a function on the global `Template` object.

{{#note}}
Today, the only templating system that has been packaged for Meteor is
Handlebars. Let us know what templating systems you'd like to use with
Meteor. Meanwhile, see the [Handlebars
documentation](http://www.handlebarsjs.com/) and [Meteor Handlebars
extensions](https://github.com/meteor/meteor/wiki/Handlebars).
{{/note}}

A template with a `name` of `hello` is rendered by calling the
function `Template.hello`, passing any data for the template:

    <!-- in myapp.html -->
    <template name="hello">
      <div class="greeting">Hello there, {{dstache}}first}} {{dstache}}last}}!</div>
    </{{! }}template>

    // in the JavaScript console
    > Template.hello({first: "Alyssa", last: "Hacker"});
     => "<div class="greeting">Hello there, Alyssa Hacker!</div>"

This returns a string. To use the template along with the [`Live
HTML`](#livehtml) system, and get DOM elements that update
automatically in place, use [`Meteor.render`](#meteor_render):

    Meteor.render(function () {
      return Template.hello({first: "Alyssa", last: "Hacker"});
    })
      => automatically updating DOM elements

The easiest way to get data into templates is by defining helper
functions in JavaScript. Just add the helper functions directly on the
`Template.[template name]` object. For example, in this template:

    <template name="players">
      {{dstache}}#each topScorers}}
        <div>{{dstache}}name}}</div>
      {{dstache}}/each}}
    </{{! }}template>

instead of passing in `topScorers` as data when we call the
template function, we could define a function on `Template.players`:

    Template.players.topScorers = function () {
      return Users.find({score: {$gt: 100}}, {sort: {score: -1}});
    };

In this case, the data is coming from a database query. When the
database cursor is passed to `#each`, it will wire up all of the
machinery to efficiently add and move DOM nodes as new results enter
the query.

Helpers can take arguments, and they receive the current template context data
in `this`. Note that some block helpers change the current context (notably
`each` and `with`):

    // in a JavaScript file
    Template.players.leagueIs = function (league) {
      return this.league === league;
    };

    <!-- in a HTML file -->
    <template name="players">
      {{dstache}}#each topScorers}}
        {{dstache}}#if leagueIs "junior"}}
          <div>Junior: {{dstache}}name}}</div>
        {{dstache}}/if}}
        {{dstache}}#if leagueIs "senior"}}
          <div>Senior: {{dstache}}name}}</div>
        {{dstache}}/if}}
      {{dstache}}/each}}
    </{{! }}template>

{{#note}}
Handlebars note: `{{dstache}}#if leagueIs "junior"}}` is
allowed because of a Meteor extension that allows nesting a helper
in a block helper. (Both `if` and `leagueIs` are
technically helpers, and stock Handlebars would not invoke
`leagueIs` here.)
{{/note}}

Helpers can also be used to pass in constant data.

    // Works fine with {{dstache}}#each sections}}
    Template.report.sections = ["Situation", "Complication", "Resolution"];

Finally, you can use an `events` declaration on a template function to set up a
table of event handlers. The format is documented at [Event
Maps](#eventmaps). The `this` argument to the event handler will be
the data context of the element that triggered the event.

    <!-- myapp.html -->
    <template name="scores">
      {{dstache}}#each player}}
        {{dstache}}> playerScore}}
      {{dstache}}/each}}
    </{{! }}template>

    <template name="playerScore">
      <div>{{dstache}}name}}: {{dstache}}score}}
        <span class="givePoints">Give points</span>
      </div>
    </{{! }}template>

    <!-- myapp.js -->
    Template.playerScore.events({
      'click .givePoints': function () {
        Users.update(this._id, {$inc: {score: 2}});
      }
    });

Putting it all together, here's an example of how you can inject
arbitrary data into your templates, and have them update automatically
whenever that data changes. See [Live HTML](#livehtml) for further
discussion.

    <!-- in myapp.html -->
    <template name="forecast">
      <div>It'll be {{dstache}}prediction}} tonight</div>
    </{{! }}template>

    <!-- in myapp.js -->
    // JavaScript: reactive helper function
    Template.forecast.prediction = function () {
      return Session.get("weather");
    };

    <!-- in the console -->
    > Session.set("weather", "cloudy");
    > document.body.appendChild(Meteor.render(Template.forecast));
    In DOM:  <div>It'll be cloudy tonight</div>

    > Session.set("weather", "cool and dry");
    In DOM:  <div>It'll be cool and dry tonight</div>

{{/better_markdown}}
</template>

<template name="packages_concept">
{{#better_markdown}}

  <h2 id="usingpackages">Using packages</h2>

All of the functionality you've read about so far is implemented as
standard Meteor packages. This is possible thanks to Meteor's
unusually powerful package and build system. The same packages work in
the browser and on the server, and packages can contain plugins that
extend the build process, such as `coffeescript` ([CoffeeScript](http://coffeescript.org)
compilation) or `templating` (compiling HTML templates).

You can see a list of available packages
with [`meteor list`](#meteorlist), add packages to your project
with [`meteor add`](#meteoradd), and remove them
with [`meteor remove`](#meteorremove).

By default all apps include the `standard-app-packages` package. This
automatically pulls in the packages that make up the core Meteor
stack. To keep things simple, these core packages are also hidden in
the output for `meteor list`, but you can read the
[source code of `standard-app-packages`](https://github.com/meteor/meteor/blob/master/packages/standard-app-packages/package.js)
to see what they are (as Meteor is pre-1.0, they may change from release to
release). If you want to build your own custom stack, just remove
`standard-app-packages` from your app and add back in whichever of the standard
packages you want to keep.

In addition to the packages in the official Meteor release being used
by your app, `meteor list` and `meteor add` also search the `packages`
directory at the top of your app. If you've downloaded an unofficial
package from Atmosphere you should unpack it into that directory (the
unofficial [Meteorite](http://oortcloud.github.io/meteorite/) tool
streamlines this process). You can also use the `packages` directory
to break your app into subpackages for your convenience &mdash; if you
are willing to brave the fact that the Meteor package format is not
documented yet and will change significantly before Meteor 1.0. See
[Writing Packages](#writingpackages).

{{/better_markdown}}
</template>


<template name="namespacing">
{{#better_markdown}}

  <h2 id="namespacing">Namespacing</h2>

Meteor's namespacing support makes it easy to write large applications
in JavaScript. Each package that you use in your app exists in its own
separate namespace, meaning that it sees only its own global variables
and any variables provided by the packages that it specifically
uses. Here's how it works.

When you declare a top-level variable, you have a choice. You can make
the variable File Scope or Package Scope.

    // File Scope. This variable will be visible only inside this
    // one file. Other files in this app or package won't see it.
    var alicePerson = {name: "alice"};

    // Package Scope. This variable is visible to every file inside
    // of this package or app. The difference is that 'var' is
    // omitted.
    bobPerson = {name: "bob"};

Notice that this is just the normal JavaScript syntax for declaring a
variable that is local or global. Meteor scans your source code for
global variable assignments and generates a wrapper that makes sure
that your globals don't escape their appropriate namespace.

In addition to File Scope and Package Scope, there are also
Exports. An export is a variable that a package makes available to you
when you use it. For example, the `email` package exports the `Email`
variable. If your app uses the `email` package (and _only_ if it uses
the `email` package!) then your app can see `Email` and you can call
`Email.send`. Most packages have only one export, but some packages
might have two or three (for example, a package that provides several
classes that work together).

You see only the exports of the packages that you use directly. If you
use package A, and package A uses package B, then you only see package
A's exports. Package B's exports don't "leak" into your namespace just
because you used package A. This keeps each namespace nice and
tidy. Each app or package only sees their own globals plus the APIs of
the packages that they specifically asked for.

When debugging your app, your browser's JavaScript console behaves as
if it were attached to your app's namespace. You see your app's
globals and the exports of the packages that your app uses
directly. You don't see the variables from inside those packages, and
you don't see the exports of your transitive dependencies (packages
that aren't used directly by your app, but that are used by packages
that are used by your app).

If you want to look inside packages from inside your in-browser
debugger, you've got two options:

* Set a breakpoint inside package code. While stopped on that
  breakpoint, the console will be in the package's namespace. You'll
  see the package's package-scope variables, imports, and also any
  file-scope variables for the file you're stopped in.

* If a package `foo` is included in your app, regardless of whether
  your app uses it directly, its exports are available in
  `Package.foo`. For example, if the `email` package is loaded, then
  you can access `Package.email.Email.send` even from namespaces that
  don't use the `email` package directly.

When declaring functions, keep in mind that `function x () {}` is just
shorthard for `var x = function () {}` in JavaScript. Consider these
examples:

    // This is the same as 'var x = function () ...'. So x() is
    // file-scope and can be called only from within this one file.
    function x () { ... }

    // No 'var', so x() is package-scope and can be called from
    // any file inside this app or package.
    x = function () { ... }

{{#note}}
Technically speaking, globals in an app (as opposed to in a package)
are actually true globals. They can't be captured in a scope that is
private to the app code, because that would mean that they wouldn't be
visible in the console during debugging! This means that app globals
actually end up being visible in packages. That should never be a
problem for properly written package code (since the app globals will
still be properly shadowed by declarations in the packages). You
certainly shouldn't depend on this quirk, and in the future Meteor may
check for it and throw an error if you do.
{{/note}}

{{/better_markdown}}
</template>


<template name="deploying">
{{#better_markdown}}

<h2 id="deploying">Deploying</h2>

Meteor is a full application server.  We include everything you need
to deploy your application on the internet: you just provide the JavaScript,
HTML, and CSS.

<h3 class="nosection">Running on Meteor's infrastructure</h3>

The easiest way to deploy your application is to use `meteor
deploy`.  We provide it because it's what, personally, we've always
wanted: an easy way to take an app idea, flesh it out over a weekend,
and put it out there for the world to use, with nothing getting in the
way of creativity.

    $ meteor deploy myapp.meteor.com

Your application is now available at myapp.meteor.com.  If
this is the first time deploying to this hostname, Meteor creates a
fresh empty database for your application.  If you want to deploy an
update, Meteor will preserve the existing data and just refresh the
code.

You can also deploy to your own domain.  Just set up the hostname you
want to use as a CNAME to `origin.meteor.com`,
then deploy to that name.

    $ meteor deploy www.myapp.com

We provide this as a free service so you can try Meteor.  It is also
helpful for quickly putting up internal betas, demos, and so on.

<h3 class="nosection">Running on your own infrastructure</h3>

You can also run your application on your own infrastructure, or any
other hosting provider like Heroku.

To get started, run

    $ meteor bundle myapp.tgz

This command will generate a fully-contained Node.js application in the form of
a tarball.  To run this application, you need to provide Node.js 0.10 and a
MongoDB server.  (The current release of Meteor has been tested with Node
0.10.25; older versions contain a serious bug that can cause production servers
to stall.) You can then run the application by invoking node, specifying the
HTTP port for the application to listen on, and the MongoDB endpoint.  If
you don't already have a MongoDB server, we can recommend our friends at
[MongoHQ](http://mongohq.com).

    $ PORT=3000 MONGO_URL=mongodb://localhost:27017/myapp node bundle/main.js

Other packages may require other environment variables (for example, the `email`
package requires a `MAIL_URL` environment variable).

{{#warning}}
For now, bundles will only run on the platform that the bundle was
created on.  To run on a different platform, you'll need to rebuild
the native packages included in the bundle.  To do that, make sure you
have `npm` available, and run the following:

    $ cd bundle/programs/server/node_modules
    $ rm -r fibers
    $ npm install fibers@1.0.1
{{/warning}}

{{/better_markdown}}
</template>


<template name="packages_writing">
{{#better_markdown}}

  <h2 id="writingpackages">Writing packages</h2>

The Meteor package format isn't officially documented and will change
before Meteor 1.0. But that hasn't stopped people like you from
creating hundreds of packages by reading the source code of existing
packages and following the model. If you do decide to create your own
packages, you will have to do some detective work, but here are some
quick tips:

* A package is simply a directory with a `package.js` file in it. Look in the
  [`packages` directory of the Meteor source
  tree](https://github.com/meteor/meteor/tree/master/packages/) for example
  `package.js` files. The format and name of the `package.js` file will change
  significantly before Meteor 1.0, but the functionality will be basically the
  same even though the syntax is different, so it will be easy to port your
  code.

* Packages explicitly list all of their source files using `api.add_files`, and
  the files are loaded exactly in the order specified. (This is different from
  apps, where Meteor scans a directory tree to find the source files.)  Don't
  forget to include any build plugin packages (such as `coffeescript` or, if
  using HTML templates, `templating`) that you require.

* Exporting a symbol from your package (see
  [Namespacing](#namespacing)) is accomplished with an `api.export` call
  from inside your `on_use` handler.

* An esoteric point about exports: they are not lvalues. You can't set
  an exported variable to a new value after exporting it. If you
  export `a = {name: 'alice'}` then you can change `a.name` anytime
  you want, but if after startup you set `a` to a whole new object
  then the packages that import `a` won't see the change. Since your
  exports are most always objects or functions, this is hardly ever an
  issue.

* Packages can use [npm modules](https://npmjs.org/). Use `Npm.depends` in your
  `package.js` to list the npm modules that you need and the specific
  versions that you want to use. Then use `Npm.require` inside your
  package to pull in the modules when you need them. Meteor strives to
  have 100% repeatable builds so that everyone on your team is always
  running the same code, and that's why you must explicitly lock your
  npm dependencies to specific versions. Behind the scenes, Meteor
  will use `npm shrinkwrap` to also lock down the versions of the
  transitive dependencies of all of the npm modules that you use.

* Whenever your package changes, Meteor will rebuild it (compiling
  non-JavaScript source files, fetching npm dependencies, constructing
  namespace wrappers, and so on). The built package will be cached and
  rebuilt only when a source file changes (tracked by SHA1) or when
  other dependencies such as build plugins change. To force a rebuild
  you can use the undocumented command `meteor rebuild-all`, but this
  should never be necessary (if it is, please send a
  [bug report](https://github.com/meteor/meteor/blob/devel/Contributing.md#filing-bug-reports)!).

* Build plugins are created with `_transitional_registerBuildPlugin`,
  an API that is very much in flux. See the `coffeescript` package for
  an example. Build plugins are fully-fledged Meteor programs in their
  own right and have their own namespace, package dependencies, source
  files and npm requirements. The old `register_extension` API is
  removed.

* It is possible to create weak dependencies between packages. If
  package A has a weak dependency on package B, it means that
  including A in an app does not force B to be included too &mdash;
  but, if B _is_ included, say by the app developer or by another
  package, then B will load before A. You can use this to make
  packages that optionally integrate with or enhance other packages if
  those packages are present. To create a weak dependency, pass
  `{weak: true}` as the third argument to `api.use`. When you weakly
  depend on a package you don't see its exports. You can detect if
  the possibly-present weakly-depended-on package is there by seeing
  if `Package.foo` exists, and get its exports from the same place.

* It is also possible to create unordered dependencies by passing
  `{unordered: true}`. An unordered dependency is the exact opposite
  of a weak dependency. If A has an unordered dependency on B, then
  including A forces B to be included as well, but doesn't require B
  to load before A. This is occasionally useful for resolving circular
  dependencies.

* The build system also supports package implication. If package A
  implies package B, then it means that when someone depends on
  package A, it's as if they also depended on package B as well. In
  particular, they get B's exports. This is done with `api.imply` and
  can be used to create umbrella packages such as
  `standard-app-packages` that are a shortcut for pulling in a set of
  packages, or it can be helpful in factoring common code out of a set
  of packages as with `accounts-base`.

* The build system understands the idea of native code and has a
  system of architecture names to ensure that packages that are
  specific to one architecture aren't run on the wrong
  architecture. For example, if you include an npm module that has a
  native extension, your built Meteor package will be specific to your
  machine architecture, but if not your built Meteor package will be
  portable.

{{/better_markdown}}
</template>
