<template name="concepts">

<h1 id="concetti">Concetti di base</h1>

Fino ad oggi abbiamo scritto le nostre SPA (Single Page Application) in
JavaScript a mano. Scrivere un'intera applicazione in un solo
linguaggio (JavaScript) con un solo formato dati (JSON) è fantastico.
Meteor è tutto ciò che avremmo voluto per scrivere queste applicazioni.

{{> whatismeteor }}
{{> structure }}
{{> data_ }}
{{> reactivity }}
{{> livehtmltemplates }}
{{> packages_concept }}
{{> namespacing }}
{{> deploying }}
{{> packages_writing }}
</template>

<template name="whatismeteor">

{{#markdown}}

<h2 id="cosmeteor">Cos'è Meteor?</h2>

Meteor è due cose:

* Una _libreria di package_: moduli già scritti ed indipendenti che puoi
utilizzare nell'applicazione.

Esitono una dozzina circa di package core in Meteor utilizzati da
praticamente tutte le app (ad esempio `webapp`, che gestisce le
connessioni HTTP, o `templating`, che permette di scrivere template
HTML che si aggiornano automaticamente quando i dati cambiano).
Poi ci sono packages opzionali come `email`, per spedire email, o il
gruppo dei Meteor Accounts (`account-password`, `accounts-facebook`,
`account-ui`, e altri) che fornisce un completo sistema di gestione
utenti pronto all'uso. Oltre a questi package "ufficiali" ce ne sono
centinaia scritti dalla comunità in [Atmosphere](https://atmosphere.meteor.com/),
che potrebbero già fare esattamente ciò che serve.

* Una _applicazione a linea di comando_ chiamata `meteor`.

`meteor` è un'applicazione simile a `make`, `rake`, oppure ai tool non
visuali di Visual Studio. Mette insieme tutti i file sorgenti e gli
asset dell'applicazione, esegue tutti i passi necessari a costruirla
(come compilare [CoffeeScript](http://coffeescript.org), minimizzare i
CSS, costruire i moduli [npm](https://npmjs.org/), o generare le source
map), installa i packages usati nell'app, e produce il bundle
dell'applicazione pronto per essere eseguito. Durante lo sviluppo fa
tutto ciò in maniera interattiva ed automatica, così che le modifiche ai
file si riflettono direttamente nel browser che esegue l'applicazione.
E' semplicissimo da usare senza configurazione, ma è anche
personalizzabile: si può aggiungere il supporto per nuovi linguaggi ed
interpreti aggiungendo package compilatori all'app.

L'idea di base nel sistema di package di Meteor è che _ogni cosa
dovrebbe funzionare allo stesso modo nel browser e sul server_
(naturalmente se ha senso che lo faccia: i browser non possono spedire
email ed il server non può gestire gli eventi del mouse). Tutto
l'ecosistema è stato costruito per supportare questo principio.

{{/markdown}}
</template>

<template name="structure">
{{#markdown}}

<h2 id="strutturadiunapp">Struttura di una applicazione</h2>

Una applicazione Meteor è un mix di JavaScript eseguito nel browser o in un'app PhoneGap,
JavaScript eseguito dal server di Meteor in un'istanza di [Node.js](http://nodejs.org),
più tutto l'HTML di supporto, regole CSS e asset statici (immagini, icone,
fonts...). Meteor automatizza la gestione e l'assemblaggio di questi
componenti. Inoltre lascia un buon grado di libertà sull'organizzazione
di file e cartelle che contengono questi componenti.

### Special Directories

By default, any JavaScript files in your Meteor folder are bundled and sent to
the client and the server. However, the names of the files and directories
inside your project can affect their load order, where they are loaded, and some
other characteristics. Here is a list of file and directory names that are
treated specially by Meteor:

- **client**

    Any directory named `client` is not loaded on the server. Similar to
    wrapping your code in `if (Meteor.isClient) { ... }`. All files loaded on
    the client are automatically concatenated and minified when in production
    mode. In development mode, each file is sent individually for easier
    debugging.
    
    HTML files in a Meteor application are treated quite a bit differently
    from a server-side framework.  Meteor scans all the HTML files in your
    directory for three top-level elements: `<head>`, `<body>`, and
    `<template>`.  The head and body sections are separately concatenated
    into a single head and body, which are transmitted to the client on
    initial page load.       

- **server**

    Any directory named `server` is not loaded on the client. Similar to
    wrapping your code in `if (Meteor.isServer) { ... }`, except the client
    never even receives the code. Any sensitive code that you don't want served
    to the client, such as code containing passwords or authentication
    mechanisms, should be kept in the `server` directory.
    
    Meteor gathers all your JavaScript files, excluding anything under the
    `client`, `public`, and `private` subdirectories, and loads them into a
    Node.js server instance.  In Meteor, your server code runs in a single
    thread per request, not in the asynchronous callback style typical of Node.
    We find the linear execution model a better fit for the typical server code
    in a Meteor application.

- **public**

    All files inside a top-level directory called `public` are served as-is to
    the client. When referencing these assets, do not include `public/` in the
    URL, write the URL as if they were all in the top level. For example,
    reference `public/bg.png` as `<img src='/bg.png' />`. This is the best place
    for `favicon.ico`, `robots.txt`, and similar files.

- **private**

    All files inside a top-level directory called `private` are only accessible
    from server code and can be loaded via the [`Assets`](#assets) API. This can
    be used for private data files and any files that are in your project
    directory that you don't want to be accessible from the outside.

- **client/compatibility**

    This folder is for compatibility JavaScript libraries that rely on variables
    declared with var at the top level being exported as globals.  Files in this
    directory are executed without being wrapped in a new variable scope.  These
    files are executed before other client-side JavaScript fies.

- **tests**

    Any directory named `tests` is not loaded anywhere. Use this for any local
    test code.

### Files outside special directories

All JavaScript files outside special directories are loaded on both the client
and the server.  That's the place for model definitions and other functions.
Meteor provides the variables [`Meteor.isClient`](#meteor_isclient) and
[`Meteor.isServer`](#meteor_isserver) so that your code can alter its behavior
depending on whether it's running on the client or the server.

CSS and HTML files outside special directories are loaded on the client only,
and cannot be used from server code.

### Example File Structure

The file structure of your Meteor app is very flexible. Here is an example layout that takes advantage of some of the special folders mentioned above.

```bash
lib/                      # common code like collections and utilities
lib/methods.js            # Meteor.methods definitions
lib/constants.js          # constants used in the rest of the code

client/compatibility      # legacy libraries that expect to be global
client/lib/               # code for the client to be loaded first
client/lib/helpers.js     # useful helpers for your client code
client/body.html          # content that goes in the <body> of your HTML
client/head.html          # content for <head> of your HTML: <meta> tags, etc
client/style.css          # some CSS code
client/<feature>.html     # HTML templates related to a certain feature
client/<feature>.js       # JavaScript code related to a certain feature

server/lib/permissions.js # sensitive permissions code used by your server
server/publications.js    # Meteor.publish definitions

public/favicon.ico        # app icon

settings.json             # configuration data to be passed to meteor --settings
mobile-config.js          # define icons and metadata for Android/iOS
```

You can also model your directory structure after the example apps. Run `meteor
create --example todos` and explore the directories to see where all the files
in a real app could go.

### File Load Order

It is best to write your application in such a way that it is insensitive to the
order in which files are loaded, for example by using
[Meteor.startup](#meteor_startup), or by moving load order sensitive code into
[packages](#usingpackages), which can explicitly control both the load order of
their contents and their load order with respect to other packages. However
sometimes load order dependencies in your application are unavoidable.

When not using special filenames and directories: 

- Files in subdirectories are loaded before files in parent directories, so that
files in the deepest subdirectory are loaded first, and files in the root
directory are loaded last. - Within a directory, files are loaded in
alphabetical order by filename.

Below is a complete list of special file and directory names that control file
load order:

- **lib**

    After sorting as described above, all files under directories named `lib`
    are moved before everything else, preserving their order.

- **main.***

    All files that match `main.*` are moved after everything else, preserving
    their order.



### Organizing Your Project

There are three main ways to organize your files into features or components.
Let's say we have two types of objects in our project: **apples** and
**oranges**.

#### Method 1: Root-Level Folders

Since the special `client`, `server`, and `lib` directories work if they are
anywhere in the path, you can use top-level folders to organize code into
modules:

```bash
apples/lib/               # code for apple-related features
apples/client/
apples/server/

oranges/lib/              # code for orange-related features
oranges/client/
oranges/server/
```

#### Method 2: Folders inside client/ and server/

```bash
lib/apples/               # common code for apples
lib/oranges/              # and oranges

client/apples/            # client code for apples
client/oranges/           # and oranges

server/apples/            # server code for apples
server/oranges/           # and oranges
```

#### Method 3: Packages

This is the ultimate in code separation, modularity, and reusability. If you put
the code for each feature in a separate package, the code for one feature won't
be able to access the code for the other feature except through exports, making
every dependency explicit. This also allows for the easiest independent testing
of features. You can also publish the packages and use them in multiple apps
with `meteor add`.

```bash
packages/apples/package.js     # files, dependencies, exports for apple feature
packages/apples/<anything>.js  # file loading is controlled by package.js

packages/oranges/package.js    # files, dependencies, exports for orange feature
packages/oranges/<anything>.js # file loading is controlled by package.js
```

{{/markdown}}
</template>

<template name="data_">
{{#markdown}}

<h2 id="datiesicurezza">Dati e sicurezza</h2>

Meteor rende la scrittura di codice lato client semplice perchè si
interfaccia sempre con un database locale. E’ un approccio
semplice, pulito e sicuro che ci risparmia di dover implementare Remote
Procedure Call, di mantenere manualmente una cache sul client (che evita
lente consultazioni al server) e di impegnarsi nella faticosa gestione
della sincronizzazione di tutti i client quando i dati cambiano.

In Meteor, il client ed il server condividono le stesse API per
l’accesso al database. Lo stesso codice &mdash; per la validazione e
l'elaborazione dei dati &mdash; può spesso girare su entrambi i lati.
La differenza è che il codice che gira lato server ha accesso diretto
al database, quello lato client *no*. Su questa distinzione si fonda il
modello di sicurezza dei dati in Meteor.

{{#note}}
Per default una nuova applicazione Meteor include i packages
`autopublish` e `insecure`, che insieme permettono ad ogni client di
avere accesso completo in lettura/scrittura al database sul server.
Sono strumenti utili in fase di prototipizzazione dell’applicazione,
ma ovviamente non adatti al prodotto finale. Quando è il momento, basta
rimuovere questi packages.
{{/note}}

Con Meteor ogni client possiede un database in memoria. Per gestire
questa cache lato client, il server *pubblica* set di documenti JSON,
ed il client *sottoscrive* questi set. Quando i documenti in un
set cambiano, il server aggiorna le cache di tutti i client.

Ad oggi la maggior parte delle applicazioni sviluppate con Meteor usa
MongoDB perchè è quello meglio supportato, ma è già previsto in futuro
il supporto per altri database. La classe [Meteor.Collection](http://docs.meteor.com/#mongo_collection)
è utilizzata per dichiarare collezioni in Mongo e manipolarle. Grazie a
`minimongo`, l’emulatore di Mongo che gira nel browser,
`Meteor.Collection` può essere usata sia lato client che server.

```js
// declare collections
// this code should be included in both the client and the server
Rooms = new Mongo.Collection("rooms");
Messages = new Mongo.Collection("messages");
Parties = new Mongo.Collection("parties");

// server: populate collections with some initial documents
Rooms.insert({name: "Conference Room A"});
var myRooms = Rooms.find({}).fetch();
Messages.insert({text: "Hello world", room: myRooms[0]._id});
Parties.insert({name: "Super Bowl Party"});
```

Ogni set di documenti è definito da una funzione di pubblicazione
sul server. La funzione di pubblicazione viene eseguita ogni volta che
un nuovo client sottoscrive quel set di documenti. I dati che
compongono un set di documenti possono provenire da qualsiasi fonte, ma
la cosa più probabile è che provengano da una query sul database.

```js
// server: publish all room documents
Meteor.publish("all-rooms", function () {
  return Rooms.find(); // everything
});

// server: publish all messages for a given room
Meteor.publish("messages", function (roomId) {
  check(roomId, String);
  return Messages.find({room: roomId});
});

// server: publish the set of parties the logged-in user can see.
Meteor.publish("parties", function () {
  return Parties.find({$or: [{"public": true},
                             {invited: this.userId},
                             {owner: this.userId}]});
});
```

Le funzioni di pubblicazione possono fornire risultati diversi per ogni
client. Nell’esempio sopra un utente loggato può vedere solo documenti
della collezione `Parties` che sono pubblici, che l’utente possiede o a
cui l’utente è stato invitato.

Una volta sottoscritto, il client usa la sua cache come un veloce
database locale, semplificando enormemente il codice lato client. Le
operazioni di lettura non richiedono mai una lenta richiesta al server.
Inoltre sono limitate al contenuto della cache: sul client una query su
tutti i documenti restituirà solo i documenti che il server ha
pubblicato per quel client.

```js
// client: start a parties subscription
Meteor.subscribe("parties");

// client: return array of Parties this client can read
return Parties.find().fetch(); // synchronous!
```

Dal lato client possiamo poi decidere di attivare e disattivare le
sottoscrizioni per regolare la quantità di dati mantenuta nella cache e
gestire al meglio il traffico sulla rete. Quando una sottoscrizione
viene disattivata, tutti i suoi documenti sono rimossi dalla cache, a
meno che lo stesso documento non venga fornito da un’altra
sottoscrizione attiva.

Quando il client *cambia* uno o più documenti manda un messaggio al
server per memorizzare la variazione. Il server verifica i cambiamenti
proposti tenendo conto di una serie di regole permetti/nega che lo
sviluppatore ha scritto sotto forma di funzioni Javascript. A questo
punto il server accetta i cambiamenti se tutte le regole sono
rispettate.

```js
// server: don't allow client to insert a party
Parties.allow({
  insert: function (userId, party) {
    return false;
  }
});

// client: this will fail
var party = { ... };
Parties.insert(party);
```

Se il server accetta le modifiche, le applica al database e
automaticamente le propaga a tutti i client che hanno sottoscritto i
documenti modificati. Se non le accetta, l’aggiornamento fallisce, il
database rimane inalterato e nessun client vede le modifiche.

Sveliamo ora che Meteor si serve di un trucco. Quando un client scrive
qualcosa nel database, la cache nel client viene aggiornata
immediatamente senza attendere la risposta del server. In questo modo
l'utente riceve immediato feedback di esecuzione della scrittura. Se
successivamente il server valida ed accetta la modifica &mdash; ed è
ciò che dovrebbe accadere nella maggioranza dei casi &mdash; il client
non necessita di ulteriore aggiornamento della schermata. Se invece il
server annulla la modifica, Meteor risincronizza la cache del client
con i dati del server.

Tutto ciò in sostanza realizza la compensazione della latenza. I
client hanno sempre una copia aggiornata dei dati e non hanno mai
bisogno di attendere il server. Quando i client modificano i dati,
le modifiche vengono immediatamente memorizzate senza attendere la
conferma dal server, pur dando a quest'ultimo l'ultima parola sulla
validità delle modifiche stesse.

{{#note}}
L'attuale release di Meteor supporta MongoDB, il famoso database basato
su documenti, e gli esempi usano le [MongoDB API](http://www.mongodb.org/display/DOCS/Manual).
Le future versioni avranno il supporto per altri database.
{{/note}}

<h3 id="dataandsecurity-authentication">Autenticazione e gestione utenti</h3>

Meteor include un sistema di autenticazione all'avanguardia: [Meteor
Accounts](#account_api). Prevede la gestione sicura dei login con password
tramite l'algoritmo [bcrypt](http://en.wikipedia.org/wiki/Bcrypt),
oppure attraverso l'integrazione con servizi esterni come Facebook,
GitHub, Google, Meetup, Twitter e Weibo. Meteor Accounts crea una
collezione [`Meteor.users`](#meteor_users) dove possono essere
memorizzati i dati utente specifici dell'applicazione.

Meteor inoltre fornisce form gia predisposte per le attività più comuni
come login, sottoscrizione, cambio password e reset della password
tramite email. Per averle basta aggiungere [Accounts UI](#accountsui)
con una sola riga di comando. Il package `accounts-ui` fornisce anche un
wizard di configurazione per impostare l'uso dei servizi esterni di
login nella propria applicazione.

<h3 id="dataandsecurity-validation">Validazione dell'input</h3>

Meteor consente di usare argomenti di tipo [JSON](http://json.org) per i metodi
e le funzioni di pubblicazione (in realtà, il protocollo di comunicazione di
Meteor supporta [EJSON](#ejson), una estensione di JSON che supporta anche
altri tipi di dati comuni, come date e buffer binari.) Sebbene JavaScript
faccia uso di tipi di dato dinamici che evitano di dover dichiarare l'esatto
tipo di ogni variabile utilizzata, è tuttavia utile assicurarsi che gli
argomenti passati dal client ai metodi ed alle funzioni di pubblicazione
siano esattamente del tipo atteso.

Meteor fornisce una [mini libreria](#check_package) per controllare che gli argomenti
e gli altri valori siano del tipo atteso. Basta invocare all'interno della funzione dei
controlli del tipo `check(username, String)` oppure `check(office, {building: String, room: Number})`.
La chiamata a `check` produrrà un errore se
l'argomento passato non è del tipo specificato.

Meteor fornisce anche un metodo veloce per accertarsi che tutti i metodi e le
funzioni di pubblicazione facciano la validazione di tutti gli argomenti. Basta
aggiungere il package <code>meteor add [audit-argument-checks](#auditargumentchecks)</code> :
tutti i metodi e le funzioni di pubblicazione che non fanno il `check`ing
produrranno un'eccezione.

{{/markdown}}
</template>

<template name="reactivity">
{{#markdown}}

<h2 id="reattivit">Reattività</h2>

Meteor sposa il concetto di [reactive programming](http://en.wikipedia.org/wiki/Reactive_programming).
Significa che il codice può essere scritto in semplice stile imperativo ma
verrà rieseguito automaticamente ogni volta che i dati da cui dipende saranno
modificati.

    Tracker.autorun(function () {
      Meteor.subscribe("messages", Session.get("currentRoomId"));
    });

Questo esempio (preso dal client di una chat room) sottoscrive dei dati in base
al valore della variabile di sessione `currentRoomId`. Se il valore di
`Session.get("currentRoomId")` cambia per qualsiasi motivo la funzione sarà
automaticamente rieseguita, ed una nuova sottoscrizione andrà a sostituire la
precedente.

Questo aggiornamento automatico si ottiene attraverso la cooperazione tra
`Session` e `Tracker.autorun`. `Tracker.autorun` decide quando eseguire una
"elaborazione reattiva" delle funzioni passate come argomento, cioè al variare
dei dati da cui ogni funzione dipende. I dati, come ad esempio quelli forniti
dall'oggetto `Session`, sanno quale codice li monitorizza e si occupano di
segnalare a quel codice che sono cambiati ed è quindi necessaria una nuova
elaborazione.

Questo schema di funzionamento (esecuzione reattiva + sorgente dati reattiva) ha
grandi benefici. Nell'esempio sopra, il programmatore non si deve preoccupare di
scrivere il codice che ri-sottoscrive al momento opportuno i dati aggiornati.
Meteor permette quindi di eliminare il codice che si occupa di tenere traccia
delle modifiche ai dati che finirebbe per intasare l'applicazione con la
conseguenza di introdurre bug.

Queste funzioni in Meteor permettono di scrivere codice che sarà eseguito in
maniera reattiva:

* [Templates](#livehtmltemplates)
* [`Tracker.autorun`](#tracker_autorun)
* [`Blaze.render`](#blaze_render) and [`Blaze.renderWithData`](#blaze_renderwithdata)

Mentre le sorgenti dati reattive che possono scatenare la riesecuzione sono:

* Le variabili memorizzate in [`Session`](#session)
* Query sulle [Collections](#find) del database
* [`Meteor.status`](#meteor_status)
* Il metodo `ready()` su un [subscription handle](#meteor_subscribe)
* [`Meteor.user`](#meteor_user)
* [`Meteor.userId`](#meteor_userid)
* [`Meteor.loggingIn`](#meteor_loggingin)

Inoltre le seguenti funzioni che ritornano un oggetto con un metodo
`stop`, vengono interrote quando il ricalcolo viene eseguito o fermato, se
usate nel codice ad esecuzione reattiva.

* [`Tracker.autorun`](#tracker_autorun) (annidata)
* [`Meteor.subscribe`](#meteor_subscribe)
* [`observe()`](#observe) e [`observeChanges()`](#observe_changes) sui cursori

Tutto ciò in Meteor è
[implementato](https://github.com/meteor/meteor/blob/master/packages/tracker/tracker.js)
in un package chiamato [`Tracker`](#tracker) piuttosto piccolo e facilmente
comprensibile. Lo si può usare per implementare nuove sorgenti dati reattive.

{{/markdown}}
</template>

<template name="livehtmltemplates">
{{#markdown}}

<h2 id="templatehtmllive">Template HTML live</h2>

I template HTML sono fondamentali per le applicazioni web. Grazie a Blaze, la
tecnologia di aggiornamento live delle pagine di Meteor, possiamo visualizzare
il codice HTML in maniera _reattiva_, e questo significa che si aggiornerà
automaticamente in base alle modifiche ai dati usati per generarlo.

Meteor makes it easy to use your favorite HTML templating language along with
Meteor's live page update technology. Just write your template as you normally
would, and Meteor will take care of making it update in realtime.
La tecnologia di aggiornamento live delle pagine di Meteor può facilmente essere
integrata con la libreria di gestione di template HTML che si preferisce. Basta
scrivere il nostro template come faremmo normalmente e Meteor si preoccuperà di
mantenerlo sempre aggiornato in tempo reale.

Meteor integra un linguaggio per la scrittura di template chiamato
[Spacebars](https://github.com/meteor/meteor/blob/devel/packages/spacebars/README.md),
ispirato da [Handlebars](http://handlebarsjs.com/). Segue in gran parte le
stesse convenzioni e la stessa sintassi di Handelbars, ma produce template
reattivi quando viene compilato.

{{#note}}
  Ad oggi l'unico sistema di templating integrato in Meteor è Spacebar, ma la
  comunità degli sviluppatori ha già creato package per altri linguaggi come
  [Jade](https://atmospherejs.com/mquandalle/jade).
{{/note}}

Per costruire un template basta creare un file nel progetto con
estensione `.html`. Nel file mettiamo un tag `<template>` e gli assegnamo
un attributo di tipo `name`. Mettiamo il contenuto del template
all'interno del tag. Meteor precompilerà il template, lo fornirà al
client, rendendolo disponibile come funzione dell'oggetto globale
`Template`.

Quando l'applicazione viene caricata, mostra a video il template speciale
chiamato `<body>`, che abbiamo creato usando l'elemento `<body>` invece di
`<template>`. Per inserire un template dentro un altro template usiamo
l'operatore `{{dstache}}> inclusion}}`.

Il modo più semplice per mettere dei dati nei template è attraverso la
definizione di funzioni helper in Javascript. Basta aggiungere le
funzioni helper con la funzione `Template.templateName.helpers({ ... })`
Vediamo come si fa:

```html
<!-- in myapp.html -->
<body>
  <h1>Today's weather!</h1>
  {{dstache}}> forecast}}
</body>

<template name="forecast">
  <div>It'll be {{dstache}}prediction}} tonight</div>
{{lt}}/template>
```

```js
// in client/myapp.js: reactive helper function
Template.forecast.helpers({
  prediction: function () {
    return Session.get("weather");
  }
});
```

```js
// in the JavaScript console
> Session.set("weather", "cloudy");
> document.body.innerHTML
 => "<h1>Today's weather!</h1> <div>It'll be cloudy tonight</div>"

> Session.set("weather", "cool and dry");
> document.body.innerHTML
 => "<h1>Today's weather!</h1> <div>It'll be cool and dry tonight</div>"
```



Per leggere i dati di un array o di un cursore di database si usa
`{{dstache}}#each}}`:

```html
<!-- in myapp.html -->
<template name="players">
  {{dstache}}#each topScorers}}
    <div>{{dstache}}name}}</div>
  {{dstache}}/each}}
{{lt}}/template>
```

```js
// in myapp.js
Template.players.helpers({
  topScorers: function () {
    return Users.find({score: {$gt: 100}}, {sort: {score: -1}});
  }
});
```

In questo caso i dati provengono da una query al database. Quando il
cursore del database viene passato ad `{{dstache}}#each}}`, vengono eseguite
tutte le operazioni per aggiungere e spostare i nodi del DOM man mano che i
risultati popolano la query.

Gli helper possono accettare argomenti, e accedono al contesto dati del
template di riferimento tramite `this`. Si noti che alcuni helper che
definiscono dei blocchi cambiano il contesto dati in uso (in particolare
`{{dstache}}#each}}` e `{{dstache}}#with}}`): 

```js
// in a JavaScript file
Template.players.helpers({
  leagueIs: function (league) {
    return this.league === league;
  }
});
```

```html
<!-- in a HTML file -->
<template name="players">
  {{dstache}}#each topScorers}}
    {{dstache}}#if leagueIs "junior"}}
      <div>Junior: {{dstache}}name}}</div>
    {{dstache}}/if}}
    {{dstache}}#if leagueIs "senior"}}
      <div>Senior: {{dstache}}name}}</div>
    {{dstache}}/if}}
  {{dstache}}/each}}
{{lt}}/template>
```

Gli helper possono essere usati anche per passare costanti.

```js
// Works fine with {{dstache}}#each sections}}
Template.report.helpers({
  sections: ["Situation", "Complication", "Resolution"]
});
```

Infine si può usare la funzione `events` di un
template per definire i gestori eventi. Il formato è
documentato in [Event Maps](#eventmaps). Il valore di `this` per il
gestore evento sarà il contesto dati dell'elemento che ha scatenato
l'evento.

```html
<!-- myapp.html -->
<template name="scores">
  {{dstache}}#each player}}
    {{dstache}}> playerScore}}
  {{dstache}}/each}}
{{lt}}/template>

<template name="playerScore">
  <div>{{dstache}}name}}: {{dstache}}score}}
    <span class="give-points">Give points</span>
  </div>
{{lt}}/template>
```

```js
// myapp.js
Template.playerScore.events({
  'click .give-points': function () {
    Users.update(this._id, {$inc: {score: 2}});
  }
});
```

Per ulteriori dettagli su Spacebars si legga
[il README di Spacebars](https://github.com/meteor/meteor/blob/devel/packages/spacebars/README.md).

{{/markdown}}
</template>

<template name="packages_concept">
{{#markdown}}

  <h2 id="utilizzodeipackage">Utilizzo dei package</h2>

Tutte le caratteristiche che abbiamo visto finora sono implementate
utilizzando i package standard di Meteor. Ciò è possibile grazie allo
straordinario sistema isomorfico di gestione dei package e costruzione
dell'applicazione in Meteor.
Isomorfico significa che i package funzionano indifferentemente nel browser, in una app mobile
e sul server. Essi possono contenere plugin che estendono gli strumenti disponibili per lo sviluppo,
come ad esempio `coffeescript` ([CoffeeScript](http://coffeescript.org) compilation) oppure
`templating` (per la compilazione di template HTML).

Anyone can publish a Meteor package, and thousands of community-written packages
have been published to date. The easiest way to browse these packages is
<a href="http://www.atmospherejs.com">Atmosphere</a>, by Percolate Studio.
You can also use the [`meteor search`](#meteorsearch) and
[`meteor show`](#meteorshow) commands.

You can add packages to your project with [`meteor add`](#meteoradd) and remove
them with [`meteor remove`](#meteorremove).
Additionally, [`meteor list`](#meteorlist) will tell you what
packages your project is using, and [`meteor update`](#meteorupdate)
will update them to the newest versions when possible.

By default all apps include the `meteor-platform` package. This
automatically pulls in the packages that make up the core Meteor
stack. If you want to build your own custom stack, just remove
`meteor-platform` from your app and add back in whichever of the standard
packages you want to keep.

Meteor uses a single-loading packaging system, meaning that it loads just one
version of every package. Before adding or upgrading to a particular version of
a package, Meteor uses a constraint solver to check if doing so will cause
other packages to break. By default, Meteor will choose conservatively. When
adding transitive dependencies (packages that other packages, but not the
application itself) depend on, Meteor will try to choose the earlier version.

In addition to the packages in the official Meteor release being used by your
app, `meteor list` and `meteor add` also search the `packages` directory at the
top of your app. You can also use the `packages` directory to break your app
into subpackages for your convenience, or to test packages that you might want
to publish. See [Writing Packages](#writingpackages).

{{/markdown}}
</template>


<template name="namespacing">
{{#markdown}}

  <h2 id="namespacing">Namespacing</h2>

Il supporto che Meteor fornisce al
[namespacing](http://it.wikipedia.org/wiki/Namespace) rende semplice
scrivere grandi applicazioni in JavaScript. Ogni package utilizzato
nell'applicazione vive in un namespace separato, e dunque vede solo le
sue variabili globali e tutte le variabili create ed utilizzate dal
package. Ecco come funziona il tutto.

Quando dichiariamo un variabile a livello più alto possiamo scegliere.
Possiamo rendere la variabile Visibile al Package o Visibile al File.

    // Visibile al File. La variabile sarà visibile solo all'interno
    // del singolo file. Gli altri file dell'applicazione o il package
    // non la vedranno.
    var alicePerson = {name: "alice"};

    // Visibile al Package. Questa variabile sarà visibile in tutti i
    // file del package o dell'applicazione. La differenza consiste
    // nell'omissione della dichiarazione `var`.
    bobPerson = {name: "bob"};

Si noti che si tratta semplicemente della sintassi JavaScript per
dichiarare variabili locali o globali. Meteor cerca nel codice sorgente
le dichiarazioni di variabili globali e le racchiude in un codice
(wrapper) per garantire che non siano visibili al di fuori del
namespace appropriato.

Oltre alla Visibilità al File ed alla Visibilità al Package, si possono
anche creare delle Export. Una export è una varibile che il package
rende disponibile quando viene utilizzata. Ad esempio, il package `email`
rende disponibile la variabile export `Email`. Se l'applicazione usa il
package `email` (e _solamente_ se lo usa!) allora `Email` è visibile
e possiamo invocare ad esempio `Email.send`. La maggior parte dei package
hanno una sola export, ma alcuni possono averne due o tre (ad esempio, un
package che fornisce diverse classi che interagiscono tra loro).

Sono visibili solo le export dei package che usiamo direttamente. Se
usiamo il package A, ed il package A usa il package B, vediamo solo le
export del package A. Le export del package B non "fuoriescono" nel
nostro namespace solo perchè usate dal package A. Ogni namespace rimane
così pulito ed ordinato. Ogni applicazione o package vede solo le
proprie variabili globali più le API dei package che sono stati
esplicitamente richiesti.

Durante il debugging, la console JavaScript del browser si comporta
come se fosse collegata al namespace dell'applicazione. Sono visibili
le variabili globali dell'applicazione e le export dei package usati
direttamente. Non sono visibili le variabili interne ai package, e
neppure le export delle dipendenze indirette (cioè i package che non
vengono usati direttamente dell'applicazione, ma indirettamente dai
package usati dall'applicazione).

Per ispezionare l'interno dei package dal debugger del browser abbiamo
due opzioni:

* Posizionare un breakpoint nel codice del package. Quando si arresta
  su quel breakpoint la console vedrà il namespace del package. Saranno
  anche visibili le variabili con visibilità al package, le import, e
  tutte le variabili con visibilità per il file in cui l'esecuzione si
  è interrotta.

* Se un package `foo` viene incluso nell'applicazione, indipendentemente
  che venga direttamente usato o meno, le sue export sono disponibili
  tramite `Package.foo`. Ad esempio se il package `email` viene incluso
  si può accedere a `Package.email.Email.send` anche dai namespace che non
  usano direttamente il package `email`.

Quando si dichiara un funzione si ricordi che `function x () {}` è
l'abbreviazione di `var x = function () {}` in JavaScript. Prendiamo
ad esempio questo codice:

    // E' equivalente a `var x = function () ...`. Quindi x() ha una
    // visibilità al file e può essere invocata nello stesso file.
    function x () { ... }

    // Non c'è `var` quindi x() ha una visibilità al package e può
    // essere invocata da qualsiasi file del package o dell'applicazione.
    x = function () { ... }

{{#note}}
Da un punto di vista strettamente tecnico, le variabili globali di una
applicazione (al contrario di quelle nei package) sono realmente
globali. Non possono avere una visibilità limitata al solo codice
dell'applicazione perchè se così fosse non sarebbero visibili nella
console durante il debugging! Questo si traduce nel fatto che le
variabili globali finiscono per essere visibili anche nei package. Non
dovrebbe mai essere un problema se il codice del package è scritto
correttamente (dal momento che le variabili dichiarate nel package
avrebbero la precedenza su quelle globali dell'applicazione).
In ogni caso non si dovrebbe fare affidamento su questa particolarità,
e in futuro Meteor potrebbe controllare che non lo si faccia e nel caso
generare un errore. 
{{/note}}

{{/markdown}}
</template>


<template name="deploying">
{{#markdown}}

<h2 id="deploying">Deploying</h2>

Meteor è un ambiente completo per scrivere applicazioni. Abbiamo incluso
tutto ciò che serve per distribuire l'applicazione su internet: basta
scrivere il codice JavaScript, HTML e CSS.

<h3 class="nosection">Usare l'infrastruttura di Meteor</h3>

Il modo più semplice per effettuare il deploy dell'applicazione (cioè
farla girare e renderla raggiungibile dagli utenti) è utilizzare il
comando `meteor deploy`. Abbiamo creato questa possibilità perché
personalmente è ciò che avremmo sempre voluto: una maniera semplice per
partire dall'idea di un'applicazione, lavorarci su nel weekend, e
renderla disponibile a tutto il mondo, senza ostacoli alla creatività. 

    $ meteor deploy myapp.meteor.com

Ora l'applicazione è disponibile all'indirizzo myapp.meteor.com. Se è
la prima volta che installiamo l'applicazione a questo indirizzo,
Meteor crea un nuovo database vuoto. Se invece stiamo aggiornando
l'applicazione, Meteor conserverà i dati esistenti aggiornando solo il
codice.

Si può anche installare l'applicazione su un dominio personalizzato.
E' sufficiente configurare lo CNAME del dominio in maniera che punti a
`origin.meteor.com` e poi fare il deploy su quel dominio.

    $ meteor deploy www.myapp.com

Forniamo questo servizio gratuitamente, in modo da poter provare Meteor.
E' anche molto utile per mettere rapidamente online una beta ad uso interno,
una demo, e così via. Si veda [meteor deploy](#meteordeploy) per ulteriori
informazioni.

<h3 class="nosection">Usare una infrastruttura proprietaria</h3>

Si può installare l'applicazione anche utilizzando una infrastruttura
proprietaria oppure usando un qualunque fornitore in grado di far girare
applicazioni node.js.

Per iniziare eseguiamo

    $ meteor build my_directory

Questo comando genererà un'intera applicazione basata su Node.js contenuta
in una [tarball](http://it.wikipedia.org/wiki/Tar_(software)). Per lanciare
l'applicazione deve essere disponibile Node.js versione 0.10 ed un server MongoDB. (L'attuale versione di Meteor è stata
testata con Node 0.10.29; le versioni precedenti contengono un bug che
potrebbe impallare i server in produzione). A questo punto si può lanciare
l'applicazione eseguendo node, specificando la porta HTTP che l'applicazione
deve ascoltare e l'istanza di MongoDB.

```bash
$ cd my_directory
$ (cd programs/server && npm install)
$ PORT=3000 MONGO_URL=mongodb://localhost:27017/myapp node main.js
```g

Altri package potrebbero necessitare di altre variabili di ambiente (ad
esempio il package `email` ha bisogno di una variabile di ambiente `MAIL_URL`).

{{/markdown}}
</template>


<template name="packages_writing">
{{#markdown}}

  <h2 id="scritturadipackage">Scrittura di package</h2>

Writing Meteor packages is easy. To initialize a meteor package, run
`meteor create --package username:packagename`, where `username` is your Meteor
Developer username. This will create a package from scratch and prefill the
directory with a package.js control file and some javascript. By default, Meteor
will take the package name from the name of the directory that contains the
package.js file.

Meteor promises repeatable builds for both packages and applications. This means
that, if you built your package on a machine, then checked the code into a
repository and checked it out elsewhere, you should get the same result. In your
package directory, you will find an automatically generated versions.json
file. This file specifies the versions of all packages used to build your
package and is part of the source. Check it into version control to ensure
repeatable builds across machines.

{{#note}}

Sometimes, packages do not just stand on their own, but function in the context
of an app (specifically, packages in the packages directory of an app). In that
case, the app's context will take precedence. Rather than using the
versions.json file as a guide, we will build the package with the same
dependencies as used by the app (we think that, in practice, it would be
confusing to find your local packages built with different versions of
things). However, we will still write the new versions.json file.

{{/note}}

Meteor uses extended semver versioning for its packages: that means that the version
number has three parts separated by dots: major version, minor version and patch version
(for example: 1.2.3) with an optional pre-release version. You can read more about it on
[semver.org](http://www.semver.org).
Additionally, because some meteor packages wrap external libraries,
Meteor supports the convention of using `_` to denote a wrap number.

You can read more about [`package.js`](#packagejs) files in the API
section.

A word on testing: since testing is an important part of the development process,
there are two common ways to test a package:

* Integration tests (putting a package directly into an application, and writing
tests against the application) is the most common way to test a package. After
creating your package, add it to your app's /packages directory and run `meteor
add`. This will add your package to your app as a local package. You can then
test and run your app as usual. Meteor will detect and respond to changes to
your local package, just as it does to your app files.

* Unit tests are run with the command [`meteor test-packages
package-name`](#meteortestpackages). As described in the [`package.js`](#packagejs)
section, you can use the `package.js` file to specify where your unit tests are
located. If you have a repository that contains only the package source, you can
test your package by specifying the path to the package directory (which must
contain a slash), such as `meteor test-packages ./`.

To publish a package, run [`meteor publish`](#meteorpublish) from the package
directory.  There are some extra restrictions on published packages: they must
contain a version (Meteor packages are versioned using
strict <a href="http://www.semver.org">semver</a> versioning) and their names
must be prefixed with the username of the author and a colon, like so:
`iron:router`. This namespacing allows for more descriptive and on-topic package
names.

{{/markdown}}
</template>
