<template name="concepts">

<h1 id="concetti">Concetti di base</h1>

Fino ad oggi abbiamo scritto le nostre SPA (Single Page Application) in
JavaScript a mano. Scrivere un'intera applicazione in un solo
linguaggio (JavaScript) con un solo formato dati (JSON) è fantastico.
Meteor è tutto ciò che avremmo voluto per scrivere queste applicazioni.

{{> whatismeteor }}
{{> structure }}
{{> data }}
{{> reactivity }}
{{> livehtml }}
{{> templates }}
{{> packages_concept }}
{{> namespacing }}
{{> deploying }}
{{> packages_writing }}
</template>

<template name="whatismeteor">

{{#better_markdown}}

<h2 id="cosmeteor">Cos'è Meteor?</h2>

Meteor è due cose:

* Una _libreria di package_: moduli già scritti ed indipendenti che puoi
utilizzare nell'applicazione.<br>
Esitono una dozzina circa di package core in Meteor utilizzati da
praticamente tutte le app (ad esempio `webapp`, che gestisce le
connessioni HTTP, o `templating`, che permette di scrivere template
HTML che si aggiornano automaticamente quando i dati cambiano).
Poi ci sono packages opzionali come `email`, per spedire email, o il
gruppo dei Meteor Accounts (`account-password`, `accounts-facebook`,
`account-ui`, e altri) che fornisce un completo sistema di gestione
utenti pronto all'uso. Oltre a questi package "ufficiali" ce ne sono
centinaia scritti dalla comunità in [Atmosphere](https://atmosphere.meteor.com/),
che potrebbero già fare esattamente ciò che serve.

* Una _applicazione a linea di comando_ chiamata `meteor`.<br>
`meteor` è un'applicazione simile a `make`, `rake`, oppure ai tool non
visuali di Visual Studio. Mette insieme tutti i file sorgenti e gli
asset dell'applicazione, esegue tutti i passi necessari a costruirla
(come compilare [CoffeeScript](http://coffeescript.org), minimizzare i
CSS, costruire i moduli [npm](https://npmjs.org/), o generare le source
map), installa i packages usati nell'app, e produce il bundle
dell'applicazione pronto per essere eseguito. Durante lo sviluppo fa
tutto ciò in maniera interattiva ed automatica, così che le modifiche ai
file si riflettono direttamente nel browser che esegue l'applicazione.
E' semplicissimo da usare senza configurazione, ma è anche
personalizzabile: si può aggiungere il supporto per nuovi linguaggi ed
interpreti aggiungendo package compilatori all'app.

L'idea di base nel sistema di package di Meteor è che _ogni cosa
dovrebbe funzionare allo stesso modo nel browser e sul server_
(naturalmente se ha senso che lo faccia: i browser non possono spedire
email ed il server non può gestire gli eventi del mouse). Tutto
l'ecosistema è stato costruito per supportare questo principio.

{{#note}}
`meteor` non può installare package da Atmosphere. Se si utilizzano
package di Atmosphere bisogna usare [Meteorite](http://oortcloud.github.io/meteorite/),
un'applicazione che gestisce ed installa i package di Atmosphere.

In Meteor 1.0, `meteor` incorporerà il pieno supporto ad Atmosphere.
{{/note}}

{{/better_markdown}}
</template>

<template name="structure">
{{#better_markdown}}

<h2 id="strutturadiunapp">Struttura di una applicazione</h2>

Una applicazione Meteor è un mix di JavaScript eseguito nel browser,
JavaScript eseguito dal server di Meteor in un'istanza di [Node.js](http://nodejs.org),
più tutto l'HTML di supporto, regole CSS e asset statici (immagini, icone,
fonts...). Meteor automatizza la gestione e l'assemblaggio di questi
componenti. Inoltre lascia un buon grado di libertà sull'organizzazione
di file e cartelle che contengono questi componenti.

Lato server vengono visti solo i file JavaScript ed i file contenuti
nella cartella `private`. Meteor raggruppa tutti i file
JavaScript, esclusi quelli nelle cartelle `client`, `public` e
`private` e li serve ad una istanza di Node.js in una fiber. In Meteor,
il codice server-side viene eseguito in un singolo thread per richiesta,
non come callback asincrona tipica di Node. Abbiamo scelto il modello
di esecuzione lineare sincrono perchè ci sembra più adatto per il
codice server di una applicazione Meteor.

Tutti i file nella cartella `private` sono resi disponibili al
solo codice server attraverso l'API [`Assets`](#assets). La cartella
`private` deve essere usata per conservare i file accessibili al codice
server side ma che non devono essere trasferiti al client, cioè i dati
privati, appunto.

Lato client vengono gestite anche altre risorse. Meteor mette insieme
e rende disponibili al client tutti i file del progetto ad
esclusione delle cartelle `server`, `public` e `private`.
I file vengono compressi e trasferiti ad ogni client. Si è liberi di
usare un unico file JavaScript per l'intera applicazione o creare una
struttura ad albero di file singoli, o una via di mezzo. 

Alcune librerie JavaScript funzionano solo se messe in
`client/compatibility`. I file in questa cartella sono eseguiti senza
essere inglobati nello scope di una nuova variabile. Significa che ogni
`var` non locale definisce una variabile globale. Inoltre questi file
vengono eseguiti prima degli altri file JavaScript client side.

Il file esterni alle cartelle `client`, `server` e `tests` vengono
caricati sia sul client che sul server! E' dove possiamo definire la
nostra base dati (il modello) e le altre funzioni. Meteor permette di
consultare le variabili [`isClient`](#meteor_isclient) e [`isServer`](#meteor_isserver)
per eseguire codice solo lato client o solo lato server. (I file della
cartella `tests` non vengono caricati da nessuna parte.)

Tutto il codice riservato che non si vuole rendere visibile lato
client, come il codice che contiene password o meccanismi di
autenticazione, dovrebbe stare nella cartella `server`.

Anche i file CSS sono raggruppati insieme: il client riceverà un unico
file con tutti i CSS (esclusi quelli eventualmente contenuti nelle
cartelle `server`, `public` e `private`).

In modalità debug i file JavaScript e CSS sono inviati divisi per
rendere il debug più semplice.

I file HTML in Meteor sono gestiti diversamente dagli altri framework
server-side. Meteor legge tutti i file HTML alla ricerca degli elementi
`<head>`, `<body>` e `<template>` nella radice della struttura.
Le sezioni head e body sono unite in un unico file trasmesso al client
al momento del caricamenteo iniziale dell'applicazione.

Le sezioni template invece sono convertite in funzioni JavaScript
disponibili nel namespace `Template`. E' un modo molto efficiente di
fornire i template HTML al client.
Si può consultare la sezione [templates](#templates) per ulteriori
dettagli.

Infine il server Meteor rende disponibili i file nella cartella `public`
allo stesso modo dei framework Rails o Django. Qui mettiamo le
immagini, `favicon.ico`, `robots.txt` e tutto il resto.

E' buona norma scrivere la nostra applicaziome in modo che sia
indipendente dall'ordine con cui i file vengono caricati, ad esempio
usando [Meteor.startup](#meteor_startup), o spostando il codice che
dipende da un particolare ordine di caricamento nei [packages](#usingpackages)
dove si può esplicitamente controllare l'ordine di caricamento del
proprio contenuto e dello stesso package rispetto agli altri.
Ciò nonostante a volte è impossibile evitare di dipendere da un preciso ordine
di caricamento. I file JavaScript e CSS vengono caricati seguendo queste regole:

* I file nelle sottodirectory vengono caricati prima dei file presenti nelle
  directory padre, quindi i file nelle subdirectory più annidate sono i primi ad
  essere caricati, mentre quelli nella directory principale sono gli ultimi.

* Nella stessa cartella i file sono caricati in ordine alfabetico.

* Dopo il riordino sopra descritto, tutti i file nella directory `lib` vengono
  caricati prima di tutti gli altri (preservando il loro ordine).

* Infine tutti i file denominati `main.*` vengono caricati dopo tutti gli altri
  (preservando il loro ordine).

{{/better_markdown}}
</template>

<template name="data">
{{#better_markdown}}

<h2 id="datiesicurezza">Dati e sicurezza</h2>

Meteor rende la scrittura di codice lato client semplice perchè si
interfaccia sempre con un database locale. E’ un approccio
semplice, pulito e sicuro che ci risparmia di dover implementare Remote
Procedure Call, di mantenere manualmente una cache sul client (che evita
lente consultazioni al server) e di impegnarsi nella faticosa gestione
della sincronizzazione di tutti i client quando i dati cambiano.

In Meteor, il client ed il server condividono le stesse API per
l’accesso al database. Lo stesso codice &mdash; per la validazione e
l'elaborazione dei dati &mdash; può spesso girare su entrambi i lati.
La differenza è che il codice che gira lato server ha accesso diretto
al database, quello lato client *no*. Su questa distinzione si fonda il
modello di sicurezza dei dati in Meteor.

{{#note}}
Per default una nuova applicazione Meteor include i packages
`autopublish` e `insecure`, che insieme permettono ad ogni client di
avere accesso completo in lettura/scrittura al database sul server.
Sono strumenti utili in fase di prototipizzazione dell’applicazione,
ma ovviamente non adatti al prodotto finale. Quando è il momento, basta
rimuovere questi packages.
{{/note}}

Con Meteor ogni client possiede un database in memoria. Per gestire
questa cache lato client, il server *pubblica* set di documenti JSON,
ed il client *sottoscrive* questi set. Quando i documenti in un
set cambiano, il server aggiorna le cache di tutti i client.

Ad oggi la maggior parte delle applicazioni sviluppate con Meteor usa
MongoDB perchè è quello meglio supportato, ma è già previsto in futuro
il supporto per altri database. La classe [Meteor.Collection](http://docs.meteor.com/#meteor_collection)
è utilizzata per dichiarare collezioni in Mongo e manipolarle. Grazie a
`minimongo`, l’emulatore di Mongo che gira nel browser,
`Meteor.Collection` può essere usata sia lato client che server.

    // declare collections
    // this code should be included in both the client and the server
    Rooms = new Meteor.Collection("rooms");
    Messages = new Meteor.Collection("messages");
    Parties = new Meteor.Collection("parties");

    // server: populate collections with some initial documents
    Rooms.insert({name: "Conference Room A"});
    var myRooms = Rooms.find({}).fetch();
    Messages.insert({text: "Hello world", room: myRooms[0]._id});
    Parties.insert({name: "Super Bowl Party"});

Ogni set di documenti è definito da una funzione di pubblicazione
sul server. La funzione di pubblicazione viene eseguita ogni volta che
un nuovo client sottoscrive quel set di documenti. I dati che
compongono un set di documenti possono provenire da qualsiasi fonte, ma
la cosa più probabile è che provengano da una query sul database.

    // server: publish all room documents
    Meteor.publish("all-rooms", function () {
      return Rooms.find(); // everything
    });

    // server: publish all messages for a given room
    Meteor.publish("messages", function (roomId) {
      check(roomId, String);
      return Messages.find({room: roomId});
    });

    // server: publish the set of parties the logged-in user can see.
    Meteor.publish("parties", function () {
      return Parties.find({$or: [{"public": true},
                                 {invited: this.userId},
                                 {owner: this.userId}]});
    });

Le funzioni di pubblicazione possono fornire risultati diversi per ogni
client. Nell’esempio sopra un utente loggato può vedere solo documenti
della collezione `Parties` che sono pubblici, che l’utente possiede o a
cui l’utente è stato invitato.

Una volta sottoscritto, il client usa la sua cache come un veloce
database locale, semplificando enormemente il codice lato client. Le
operazioni di lettura non richiedono mai una lenta richiesta al server.
Inoltre sono limitate al contenuto della cache: sul client una query su
tutti i documenti restituirà solo i documenti che il server ha
pubblicato per quel client.

    // client: start a parties subscription
    Meteor.subscribe("parties");

    // client: return array of Parties this client can read
    return Parties.find().fetch(); // synchronous!

Dal lato client possiamo poi decidere di attivare e disattivare le
sottoscrizioni per regolare la quantità di dati mantenuta nella cache e
gestire al meglio il traffico sulla rete. Quando una sottoscrizione
viene disattivata, tutti i suoi documenti sono rimossi dalla cache, a
meno che lo stesso documento non venga fornito da un’altra
sottoscrizione attiva.

Quando il client *cambia* uno o più documenti manda un messaggio al
server per memorizzare la variazione. Il server verifica i cambiamenti
proposti tenendo conto di una serie di regole permetti/nega che lo
sviluppatore ha scritto sotto forma di funzioni Javascript. A questo
punto il server accetta i cambiamenti se tutte le regole sono
rispettate.

    // server: don't allow client to insert a party
    Parties.allow({
      insert: function (userId, party) {
        return false;
      }
    });

    // client: this will fail
    var party = { ... };
    Parties.insert(party);

Se il server accetta le modifiche, le applica al database e
automaticamente le propaga a tutti i client che hanno sottoscritto i
documenti modificati. Se non le accetta, l’aggiornamento fallisce, il
database rimane inalterato e nessun client vede le modifiche.

Sveliamo ora che Meteor si serve di un trucco. Quando un client scrive
qualcosa nel database, la cache nel client viene aggiornata
immediatamente senza attendere la risposta del server. In questo modo
l'utente riceve immediato feedback di esecuzione della scrittura. Se
successivamente il server valida ed accetta la modifica &mdash; ed è
ciò che dovrebbe accadere nella maggioranza dei casi &mdash; il client
non necessita di ulteriore aggiornamento della schermata. Se invece il
server annulla la modifica, Meteor risincronizza la cache del client
con i dati del server.

Tutto ciò in sostanza realizza la compensazione della latenza. I
client hanno sempre una copia aggiornata dei dati e non hanno mai
bisogno di attendere il server. Quando i client modificano i dati,
le modifiche vengono immediatamente memorizzate senza attendere la
conferma dal server, pur dando a quest'ultimo l'ultima parola sulla
validità delle modifiche stesse.

{{#note}}
L'attuale release di Meteor supporta MongoDB, il famoso database basato
su documenti, e gli esempi usano le [MongoDB API](http://www.mongodb.org/display/DOCS/Manual).
Le future versioni avranno il supporto per altri database.
{{/note}}

<h3 id="dataandsecurity-authentication">Autenticazione e gestione utenti</h3>

Meteor include un sistema di autenticazione all'avanguardia: [Meteor
Accounts](#account_api). Prevede la gestione dei login con password
tramite [Secure Remote Password control](http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol),
oppure attraverso l'integrazione con servizi esterni come Facebook,
GitHub, Google, Meetup, Twitter e Weibo. Meteor Accounts crea una
collezione [`Meteor.users`](#meteor_users) dove possono essere
memorizzati i dati utente specifici dell'applicazione.

Meteor inoltre fornisce form gia predisposte per le attività più comuni
come login, sottoscrizione, cambio password e reset della password
tramite email. Per averle basta aggiungere [Accounts UI](#accountsui)
con una sola riga di comando. Il package `accounts-ui` fornisce anche un
wizard di configurazione per impostare l'uso dei servizi esterni di
login nella propria applicazione.

<h3 id="dataandsecurity-validation">Validazione dell'input</h3>

Meteor consente di usare argomenti di tipo [JSON](http://json.org) per i metodi
e le funzioni di pubblicazione (in realtà, il protocollo di comunicazione di
Meteor supporta [EJSON](#ejson), una estensione di JSON che supporta anche
altri tipi di dati comuni, come date e buffer binari.) Sebbene JavaScript
faccia uso di tipi di dato dinamici che evitano di dover dichiarare l'esatto
tipo di ogni variabile utilizzata, è tuttavia utile assicurarsi che gli
argomenti passati dal client ai metodi ed alle funzioni di pubblicazione
siano esattamente del tipo atteso.

Meteor fornisce una [mini libreria](#match) per controllare che gli argomenti
e gli altri valori siano del tipo atteso. Basta invocare dei controlli del
tipo `check(username, String)` oppure `check(office, {building: String, room: Number})`
prima di chiamare ogni funzione. La chiamata a `check` produrrà un errore se
l'argomento passato non è del tipo specificato.

Meteor fornisce anche un metodo veloce per accertarsi che tutti i metodi e le
funzioni di pubblicazione facciano la validazione di tutti gli argomenti. Basta
aggiungere il package <code>meteor add [audit-argument-checks](#auditargumentchecks)</code> :
tutti i metodi e le funzioni di pubblicazione che non fanno il `check`ing
produrranno un'eccezione.

{{/better_markdown}}
</template>

<template name="reactivity">
{{#better_markdown}}

<h2 id="reattivit">Reattività</h2>

Meteor sposa il concetto di [reactive programming](http://en.wikipedia.org/wiki/Reactive_programming).
Significa che il codice può essere scritto in semplice stile imperativo ma
verrà rieseguito automaticamente ogni volta che i dati da cui dipende saranno
modificati.

    Deps.autorun(function () {
      Meteor.subscribe("messages", Session.get("currentRoomId"));
    });

Questo esempio (preso dal client di una chat room) sottoscrive dei dati in base
al valore della variabile di sessione `currentRoomId`. Se il valore di
`Session.get("currentRoomId")` cambia per qualsiasi motivo la funzione sarà
automaticamente rieseguita, ed una nuova sottoscrizione andrà a sostituire la
precedente.

Questo aggiornamento automatico si ottiene attraverso la cooperazione tra
`Session` e `Deps.autorun`. `Deps.autorun` decide quando eseguire una
"elaborazione reattiva" delle funzioni passate come argomento, cioè al variare
dei dati da cui ogni funzione dipende. I dati, come ad esempio quelli forniti
dall'oggetto `Session`, sanno quale codice li monitorizza e si occupano di
segnalare a quel codice che sono cambiati ed è quindi necessaria una nuova
elaborazione.

Questo schema di funzionamento (esecuzione reattiva + sorgente dati reattiva) ha
grandi benefici. Nell'esempio sopra, il programmatore non si deve preoccupare di
scrivere il codice che ri-sottoscrive al momento opportuno i dati aggiornati.
Meteor permette quindi di eliminare il codice che si occupa di tenere traccia
delle modifiche ai dati che finirebbe per intasare l'applicazione con la
conseguenza di introdurre bug.

Queste funzioni in Meteor permettono di scrivere codice che sarà eseguito in
maniera reattiva:

* [Templates](#templates)
* [`Meteor.render`](#meteor_render) e [`Meteor.renderList`](#meteor_renderlist)
* [`Deps.autorun`](#deps_autorun)

Mentre le sorgenti dati reattive che possono scatenare la riesecuzione sono:

* Le variabili memorizzate in [`Session`](#session)
* Query sulle [Collections](#find) del database
* [`Meteor.status`](#meteor_status)
* Il metodo `ready()` su un [subscription handle](#meteor_subscribe)
* [`Meteor.user`](#meteor_user)
* [`Meteor.userId`](#meteor_userid)
* [`Meteor.loggingIn`](#meteor_loggingin)

Inoltre le seguenti funzioni che ritornano un oggetto con un metodo
`stop`, vengono interrote quando il ricalcolo viene eseguito o fermato, se
usate nel codice ad esecuzione reattiva.

* [`Deps.autorun`](#deps_autorun) (annidata)
* [`Meteor.subscribe`](#meteor_subscribe)
* [`observe()`](#observe) e [`observeChanges()`](#observe_changes) sui cursori

Tutto ciò in Meteor è
[implementato](https://github.com/meteor/meteor/blob/master/packages/deps/deps.js)
in un package chiamato [`Deps`](#deps) piuttosto piccolo e facilmente
comprensibile. Lo si può usare per implementare nuove sorgenti dati reattive.

{{/better_markdown}}
</template>

<template name="livehtml">
{{#better_markdown}}

<h2 id="livehtml">Live HTML</h2>

I template HTML sono fondamentali per le applicazioni web. Con la tecnologia di
aggiornamento live delle pagine possiamo visualizzare il codice HTML in maniera _reattiva_, e questo significa che si aggiornerà automaticamente in base alle
modifiche ai dati usati per generarlo.

Questa caratteristica opzionale funziona con qualsiasi libreria di templating
HTML, o anche con l'HTML generato manualmente in JavaScript. Ecco un esempio:

    var fragment = Meteor.render(
      function () {
        var name = Session.get("name") || "Anonymous";
        return "<div>Hello, " + name + "</div>";
      });
    document.body.appendChild(fragment);

    Session.set("name", "Bob"); // page updates automatically!

[`Meteor.render`](#meteor_render) si aspetta una funzione di rendering, cioè
una funzione che ritorna una stringa contenente HTML. Ritorna un
`DocumentFragment` che si aggiorna automaticamente. Quando i dati usati dalla
funzione di rendering variano viene eseguita nuovamente. I nodi del DOM del
`DocumentFragment` aggiornano se stessi sul posto, non importa in quale punto
della pagina sono stati messi. E' completamente automatico.
[`Meteor.render`](#meteor_render) usa una [elaborazione reattiva](#reattivit) per scoprire quali dati sono usati dalla funzione di rendering. 

In genere però, queste funzioni non si usano direttamente &mdash; ma si usa
il package preferito per la gestione dei template, come Handlebars o Jade. Le
funzioni `render` e `renderList` sono messe a disposizione di chi desidera
implementare nuove librerie di templating. 

Meteor esegue gli aggiornamenti all'interfaccia solo quando il codice
dell'applicazione non è in esecuzione. In questo modo siamo sicuri che il DOM
non ci si modificherà da sotto i piedi. Ma a volte ci interessa il contrario.
Ad esempio se abbiamo appena inserito un record nel database potremmo voler
forzare il DOM ad aggiornarsi in modo da poterci riferire ai nuovi elementi
da una libreria come jQuery. In questo caso usiamo [`Deps.flush`](#deps_flush)
per aggiornare il DOM immediatamente. 

Quando gli elementi del DOM con aggiornamento live vengono rimossi dalla
pagina, vengono automaticamente resettati &mdash; le callback vengono
disattivate e le query al database interrotte, e non si aggiornano più. Per
questo non ci sarà mai bisogno di preoccuparsi dei [template
zombie](http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/)
che infestano la logica di aggiornamento scritta a mano. Per proteggere gli
elementi da questo meccanismo di reset bisogna esser certi che siano presenti
a video quando l'esecuzione del codice torna al loop degli eventi, o prima di
invocare [`Deps.flush`](#deps_flush).

Un altro spinoso problema delle applicazioni scritte a mano è la preservazione
dell'elemento. Supponiamo che l'utente stia digitando in un elemento `<input> e
che in quel momento l'area della pagina dove si trova venga ridisegnata.
L'utente potrebbe trovarsi in una situazione spiacevole visto che il fuoco, la
posizione del cursore, il testo parzialmente inserito e la sequenza per ottenere caratteri accentati vengono perse quando l'`<input>` viene ricreato.

E' un altro problema che Meteor risove per noi. Quando i template vengono
ridisegnati si possono specificare gli elementi da preservare usando nel
template la direttiva [`preserve`](#template_preserve). Meteor preserverà
questi elementi quando il template che li contiene viene ridisegnato, ma
continuerà ad aggiornare i figli riportando ogni cambio degli attributi. 

{{/better_markdown}}
</template>

<template name="templates">
{{#better_markdown}}

<h2 id="templates">Templates</h2>

Meteor permette di utilizzare con semplicità la libreria di gestione
template preferita, come ad esempio Handlebars oppure Jade, insieme
alla tecnologia di aggiornamento live della pagina. Basta scrivere il
template nel modo che siamo soliti fare e Meteor gestirà gli
aggiornamenti in tempo reale.

Per sfruttare questa possibilità basta creare un file nel progetto con
estensione `.html`. Nel file mettiamo un tag `<template>` e gli assegnamo
un attributo di tipo `name`. Mettiamo il contenuto del template
all'interno del tag. Meteor precompilerà il template, lo fornirà al
client, rendendolo disponibile come funzione dell'oggetto globale
`Template`.

{{#note}}
Ad oggi l'unica libreria di gestione template pacchettizzata per l'uso
con Meteor è Handlebars. Fateci sapere quale altra libreria di gestione
template vorreste usare con Meteor. Intanto potete consultare la
[documentazione di Handlebars](http://www.handlebarsjs.com/) e le
[estensioni di Handlebars per Meteor](https://github.com/meteor/meteor/wiki/Handlebars).
{{/note}}

Un template con `name` uguale ad `hello` viene disegnato invocando la
funzione `Template.hello`, passando i dati per il template:

    <!-- in myapp.html -->
    <template name="hello">
      <div class="greeting">Hello there, {{dstache}}first}} {{dstache}}last}}!</div>
    </{{! }}template>

    // in the JavaScript console
    > Template.hello({first: "Alyssa", last: "Hacker"});
     => "<div class="greeting">Hello there, Alyssa Hacker!</div>"

Che ritorna una stringa. Per usare il template insieme al sistema di
[`Live HTML`](#livehtml), ed avere elementi del DOM che si aggiornano
automaticamente sul posto, bisogna usare [`Meteor.render`](#meteor_render):

    Meteor.render(function () {
      return Template.hello({first: "Alyssa", last: "Hacker"});
    })
      => automatically updating DOM elements

Il modo più semplice per mettere dei dati nei template è attraverso la
definizione di funzioni helper in Javascript. Basta aggiungere le
funzioni helper direttamente all'oggetto `Template.[template name]`.
Ad esempio in questo template:

    <template name="players">
      {{dstache}}#each topScorers}}
        <div>{{dstache}}name}}</div>
      {{dstache}}/each}}
    </{{! }}template>

invece di passare `topScorers` come parametro quando chiamiamo la
funzione del template, potremmo definire una funzione in
`Template.players`:

    Template.players.topScorers = function () {
      return Users.find({score: {$gt: 100}}, {sort: {score: -1}});
    };

In questo caso i dati provengono da una quary al database. Quando il
cursore del database viene passato ad `#each`, vengono eseguite tutte
le operazioni per aggiungere e spostare i nodi del DOM man mano che i
risultati popolano la query.

Gli helper possono accettare argomenti, e accedono al contesto dati del
template di riferimento tramite `this`. Si noti che alcuni helper che
definiscono dei blocchi cambiano il contesto dati in uso (in particolare
`each` e `with`): 

    // in a JavaScript file
    Template.players.leagueIs = function (league) {
      return this.league === league;
    };

    <!-- in a HTML file -->
    <template name="players">
      {{dstache}}#each topScorers}}
        {{dstache}}#if leagueIs "junior"}}
          <div>Junior: {{dstache}}name}}</div>
        {{dstache}}/if}}
        {{dstache}}#if leagueIs "senior"}}
          <div>Senior: {{dstache}}name}}</div>
        {{dstache}}/if}}
      {{dstache}}/each}}
    </{{! }}template>

{{#note}}
Nota su Handlebars: `{{dstache}}#if leagueIs "junior"}}` qui può essere
usato grazie ad una estensione per Meteor che permette l'annidamento di
un helper dentro un altro helper che definisce un blocco. (Sia `if` che
`leagueIs` sono helper, tecnicamente, e Handlebars normalmente non
invocherebbe `leagueIs` in questo caso.)
{{/note}}

Gli helper possono essere usati anche per passare costanti.

    // Works fine with {{dstache}}#each sections}}
    Template.report.sections = ["Situation", "Complication", "Resolution"];

Infine si può usare la dichiarazione `events` nella funzione di un
template per definire una tabella di gestori eventi. Il formato è
documentato in [Event Maps](#eventmaps). L'argomento `this` per il
gestore eventi sarà il contesto dati dell'elemento che ha scatenato
l'evento.

    <!-- myapp.html -->
    <template name="scores">
      {{dstache}}#each player}}
        {{dstache}}> playerScore}}
      {{dstache}}/each}}
    </{{! }}template>

    <template name="playerScore">
      <div>{{dstache}}name}}: {{dstache}}score}}
        <span class="givePoints">Give points</span>
      </div>
    </{{! }}template>

    <!-- myapp.js -->
    Template.playerScore.events({
      'click .givePoints': function () {
        Users.update(this._id, {$inc: {score: 2}});
      }
    });

Mettendo insieme quanto abbiamo detto, ecco un esempio di come si
possono inserire dati nel template a nostro piacimento, ed ottenere
un aggiornamento automatico ogni volta che i dati cambiano. Si veda
[Live HTML](#livehtml) per ulteriori approfondimenti.

    <!-- in myapp.html -->
    <template name="forecast">
      <div>It'll be {{dstache}}prediction}} tonight</div>
    </{{! }}template>

    <!-- in myapp.js -->
    // JavaScript: reactive helper function
    Template.forecast.prediction = function () {
      return Session.get("weather");
    };

    <!-- in the console -->
    > Session.set("weather", "cloudy");
    > document.body.appendChild(Meteor.render(Template.forecast));
    In DOM:  <div>It'll be cloudy tonight</div>

    > Session.set("weather", "cool and dry");
    In DOM:  <div>It'll be cool and dry tonight</div>

{{/better_markdown}}
</template>

<template name="packages_concept">
{{#better_markdown}}

  <h2 id="utilizzodeipackages">Utilizzo dei packages</h2>

Tutte le caratteristiche che abbiamo visto finora sono implementate
utilizzando i package standard di Meteor. Ciò è possibile grazie allo
straordinario sistema di costruzione e gestione dei package in Meteor.
I package funzionano indifferentemente sul server e nel browser, e
possono contenere plugin che estendono gli strumenti disponibili per lo sviluppo, come ad esempio `coffeescript`
([CoffeeScript](http://coffeescript.org) compilation) oppure `templating`
(per la compilazione di template HTML).

Per visualizzare la lista dei package disponibili si usa
[`meteor list`](#meteorlist), per aggiungere package al progetto
[`meteor add`](#meteoradd) e per rimuoverli
[`meteor remove`](#meteorremove).

Per impostazione predefinita tutte le applicazioni includono il package
`standard-app-packages`. Questo package include a sua volta tutti i package
che compongono il nucleo di base di Meteor. Per semplicità questi package
non sono inclusi nell'elenco prodotto da `meteor list`, ma è possibile
leggere il [codice sorgente di `standard-app-packages`](https://github.com/meteor/meteor/blob/master/packages/standard-app-packages/package.js)
per vedere quali sono (si ricordi che poichè Meteor è in pre-1.0 possono
ancora subire modifiche). Se si desidera costruire un nucleo di base
personalizzato, basta rimuovere `standard-app-packages` dall'applicazione
ed aggiungere singolarmente i package standard che vogliamo usare.

Oltre a mostrare i package ufficiali della versione di Meteor in uso,
`meteor list` e `meteor add` cercano anche nella cartella `packages`
nella radice della nostra applicazione. I package non ufficiali scaricati
da Atmosphere andrebbero installati in questa cartella
(l'utility [Meteorite](http://oortcloud.github.io/meteorite/) semplifica
questa operazione). Si può anche usare la cartella `packages` per
suddividere l'applicazione in subpackage per comodità &mdash; se si è
sufficientemente coraggiosi da non temere che il formato dei package
cambierà in maniera significativa prima di Meteor 1.0 e che non è ancora ufficialmente documentato. Si veda
[Scrittura di packages](#scritturadipackages).

{{/better_markdown}}
</template>


<template name="namespacing">
{{#better_markdown}}

  <h2 id="namespacing">Namespacing</h2>

Il supporto che Meteor fornisce al
[namespacing](http://it.wikipedia.org/wiki/Namespace) rende semplice
scrivere grandi applicazioni in JavaScript. Ogni package utilizzato
nell'applicazione vive in un namespace separato, e dunque vede solo le
sue variabili globali e tutte le variabili create ed utilizzate dal
package. Ecco come funziona il tutto.

Quando dichiariamo un variabile a livello più alto possiamo scegliere.
Possiamo rendere la variabile Visibile al Package o Visibile al File.

    // Visibile al File. La variabile sarà visibile solo all'interno
    // del singolo file. Gli altri file dell'applicazione o il package
    // non la vedranno.
    var alicePerson = {name: "alice"};

    // Visibile al Package. Questa variabile sarà visibile in tutti i
    // file del package o dell'applicazione. La differenza consiste
    // nell'omissione della dichiarazione `var`.
    bobPerson = {name: "bob"};

Si noti che si tratta semplicemente della sintassi JavaScript per
dichiarare variabili locali o globali. Meteor cerca nel codice sorgente
le dichiarazioni di variabili globali e le racchiude in un codice
(wrapper) per garantire che non siano visibili al di fuori del
namespace appropriato.

Oltre alla Visibilità al File ed alla Visibilità al Package, si possono
anche creare delle Export. Una export è una varibile che il package
rende disponibile quando viene utilizzata. Ad esempio, il package `email`
rende disponibile la variabile export `Email`. Se l'applicazione usa il
package `email` (e _solamente_ se lo usa!) allora `Email` è visibile
e possiamo invocare ad esempio `Email.send`. La maggior parte dei package
hanno una sola export, ma alcuni possono averne due o tre (ad esempio, un
package che fornisce diverse classi che interagiscono tra loro).

Sono visibili solo le export dei package che usiamo direttamente. Se
usiamo il package A, ed il package A usa il package B, vediamo solo le
export del package A. Le export del package B non "fuoriescono" nel
nostro namespace solo perchè usate dal package A. Ogni namespace rimane
così pulito ed ordinato. Ogni applicazione o package vede solo le
proprie variabili globali più le API dei package che sono stati
esplicitamente richiesti.

Durante il debugging, la console JavaScript del browser si comporta
come se fosse collegata al namespace dell'applicazione. Sono visibili
le variabili globali dell'applicazione e le export dei package usati
direttamente. Non sono visibili le variabili interne ai package, e
neppure le export delle dipendenze indirette (cioè i package che non
vengono usati direttamente dell'applicazione, ma indirettamente dai
package usati dall'applicazione).

Per ispezionare l'interno dei package dal debugger del browser abbiamo
due opzioni:

* Posizionare un breakpoint nel codice del package. Quando si arresta
  su quel breakpoint la console vedrà il namespace del package. Saranno
  anche visibili le variabili con visibilità al package, le import, e
  tutte le variabili con visibilità per il file in cui l'esecuzione si
  è interrotta.

* Se un package `foo` viene incluso nell'applicazione, indipendentemente
  che venga direttamente usato o meno, le sue export sono disponibili
  tramite `Package.foo`. Ad esempio se il package `email` viene incluso
  si può accedere a `Package.email.Email.send` anche dai namespace che non
  usano direttamente il package `email`.

Quando si dichiara un funzione si ricordi che `function x () {}` è
l'abbreviazione di `var x = function () {}` in JavaScript. Prendiamo
ad esempio questo codice:

    // E' equivalente a `var x = function () ...`. Quindi x() ha una
    // visibilità al file e può essere invocata nello stesso file.
    function x () { ... }

    // Non c'è `var` quindi x() ha una visibilità al package e può
    // essere invocata da qualsiasi file del package o dell'applicazione.
    x = function () { ... }

{{#note}}
Da un punto di vista strettamente tecnico, le variabili globali di una
applicazione (al contrario di quelle nei package) sono realmente
globali. Non possono avere una visibilità limitata al solo codice
dell'applicazione perchè se così fosse non sarebbero visibili nella
console durante il debugging! Questo si traduce nel fatto che le
variabili globali finiscono per essere visibili anche nei package. Non
dovrebbe mai essere un problema se il codice del package è scritto
correttamente (dal momento che le variabili dichiarate nel package
avrebbero la precedenza su quelle globali dell'applicazione).
In ogni caso non si dovrebbe fare affidamento su questa particolarità,
e in futuro Meteor potrebbe controllare che non lo si faccia e nel caso
generare un errore. 
{{/note}}

{{/better_markdown}}
</template>


<template name="deploying">
{{#better_markdown}}

<h2 id="deploying">Deploying</h2>

Meteor è un ambiente completo per scrivere applicazioni. Abbiamo incluso
tutto ciò che serve per distribuire l'applicazione su internet: basta
scrivere il codice JavaScript, HTML e CSS.

<h3 class="nosection">Usare l'infrastruttura di Meteor</h3>

Il modo più semplice per effettuare il deploy dell'applicazione (cioè
farla girare e renderla raggiungibile dagli utenti) è utilizzare il
comando `meteor deploy`. Abbiamo creato questa possibilità perché
personalmente è ciò che avremmo sempre voluto: una maniera semplice per
partire dall'idea di un'applicazione, lavorarci su nel weekend, e
renderla disponibile a tutto il mondo, senza ostacoli alla creatività. 

    $ meteor deploy myapp.meteor.com

Ora l'applicazione è disponibile all'indirizzo myapp.meteor.com. Se è
la prima volta che installiamo l'applicazione a questo indirizzo,
Meteor crea un nuovo database vuoto. Se invece stiamo aggiornando
l'applicazione, Meteor conserverà i dati esistenti aggiornando solo il
codice.

Si può anche installare l'applicazione su un dominio personalizzato.
E' sufficiente configurare lo CNAME del dominio in maniera che punti a
`origin.meteor.com` e poi fare il deploy su quel dominio.

    $ meteor deploy www.myapp.com

Forniamo questo servizio gratuitamente, in modo da poter provare Meteor.
E' anche molto utile per mettere rapidamente online una beta ad uso interno,
una demo, e così via.

<h3 class="nosection">Usare una infrastruttura proprietaria</h3>

Si può installare l'applicazione anche utilizzando una infrastruttura
proprietaria oppure usando un fornitore come Heroku.

Per iniziare eseguiamo

    $ meteor bundle myapp.tgz

Questo comando genererà un'intera applicazione basata su Node.js contenuta
in una [tarball](http://it.wikipedia.org/wiki/Tar_(software)). Per lanciare
l'applicazione deve essere disponibile Node.js versione 0.10 ed un server MongoDB. (L'attuale versione di Meteor è stata
testata con Node 0.10.25; le versioni precedenti contengono un bug che
potrebbe impallare i server in produzione). A questo punto si può lanciare
l'applicazione eseguendo node, specificando la porta HTTP che l'applicazione
deve ascoltare e l'istanza di MongoDB. Se non si dispone già di un server
MongoDB raccomandiamo di dare un'occhiata ai nostri amici di
[MongoHQ](http://mongohq.com).

    $ PORT=3000 MONGO_URL=mongodb://localhost:27017/myapp node bundle/main.js

Altri package potrebbero necessitare di altre variabili di ambiente (ad
esempio il package `email` ha bisogno di una variabile di ambiente `MAIL_URL`).

{{#warning}}
Attualmente un bundle funziona solo in un ambiente uguale a quello in cui
è stato creato. Per girare in un diverso ambiente è necessario ricostruire
i package nativi inclusi nel bundle. Per farlo dobbiamo disporre di `npm` ed eseguire:

    $ cd bundle/programs/server/node_modules
    $ rm -r fibers
    $ npm install fibers@1.0.1
{{/warning}}

{{/better_markdown}}
</template>


<template name="packages_writing">
{{#better_markdown}}

  <h2 id="writingpackages">Writing packages</h2>

The Meteor package format isn't officially documented and will change
before Meteor 1.0. But that hasn't stopped people like you from
creating hundreds of packages by reading the source code of existing
packages and following the model. If you do decide to create your own
packages, you will have to do some detective work, but here are some
quick tips:

* A package is simply a directory with a `package.js` file in it. Look in the
  [`packages` directory of the Meteor source
  tree](https://github.com/meteor/meteor/tree/master/packages/) for example
  `package.js` files. The format and name of the `package.js` file will change
  significantly before Meteor 1.0, but the functionality will be basically the
  same even though the syntax is different, so it will be easy to port your
  code.

* Packages explicitly list all of their source files using `api.add_files`, and
  the files are loaded exactly in the order specified. (This is different from
  apps, where Meteor scans a directory tree to find the source files.)  Don't
  forget to include any build plugin packages (such as `coffeescript` or, if
  using HTML templates, `templating`) that you require.

* Exporting a symbol from your package (see
  [Namespacing](#namespacing)) is accomplished with an `api.export` call
  from inside your `on_use` handler.

* An esoteric point about exports: they are not lvalues. You can't set
  an exported variable to a new value after exporting it. If you
  export `a = {name: 'alice'}` then you can change `a.name` anytime
  you want, but if after startup you set `a` to a whole new object
  then the packages that import `a` won't see the change. Since your
  exports are most always objects or functions, this is hardly ever an
  issue.

* Packages can use [npm modules](https://npmjs.org/). Use `Npm.depends` in your
  `package.js` to list the npm modules that you need and the specific
  versions that you want to use. Then use `Npm.require` inside your
  package to pull in the modules when you need them. Meteor strives to
  have 100% repeatable builds so that everyone on your team is always
  running the same code, and that's why you must explicitly lock your
  npm dependencies to specific versions. Behind the scenes, Meteor
  will use `npm shrinkwrap` to also lock down the versions of the
  transitive dependencies of all of the npm modules that you use.

* Whenever your package changes, Meteor will rebuild it (compiling
  non-JavaScript source files, fetching npm dependencies, constructing
  namespace wrappers, and so on). The built package will be cached and
  rebuilt only when a source file changes (tracked by SHA1) or when
  other dependencies such as build plugins change. To force a rebuild
  you can use the undocumented command `meteor rebuild-all`, but this
  should never be necessary (if it is, please send a
  [bug report](https://github.com/meteor/meteor/blob/devel/Contributing.md#filing-bug-reports)!).

* Build plugins are created with `_transitional_registerBuildPlugin`,
  an API that is very much in flux. See the `coffeescript` package for
  an example. Build plugins are fully-fledged Meteor programs in their
  own right and have their own namespace, package dependencies, source
  files and npm requirements. The old `register_extension` API is
  removed.

* It is possible to create weak dependencies between packages. If
  package A has a weak dependency on package B, it means that
  including A in an app does not force B to be included too &mdash;
  but, if B _is_ included, say by the app developer or by another
  package, then B will load before A. You can use this to make
  packages that optionally integrate with or enhance other packages if
  those packages are present. To create a weak dependency, pass
  `{weak: true}` as the third argument to `api.use`. When you weakly
  depend on a package you don't see its exports. You can detect if
  the possibly-present weakly-depended-on package is there by seeing
  if `Package.foo` exists, and get its exports from the same place.

* It is also possible to create unordered dependencies by passing
  `{unordered: true}`. An unordered dependency is the exact opposite
  of a weak dependency. If A has an unordered dependency on B, then
  including A forces B to be included as well, but doesn't require B
  to load before A. This is occasionally useful for resolving circular
  dependencies.

* The build system also supports package implication. If package A
  implies package B, then it means that when someone depends on
  package A, it's as if they also depended on package B as well. In
  particular, they get B's exports. This is done with `api.imply` and
  can be used to create umbrella packages such as
  `standard-app-packages` that are a shortcut for pulling in a set of
  packages, or it can be helpful in factoring common code out of a set
  of packages as with `accounts-base`.

* The build system understands the idea of native code and has a
  system of architecture names to ensure that packages that are
  specific to one architecture aren't run on the wrong
  architecture. For example, if you include an npm module that has a
  native extension, your built Meteor package will be specific to your
  machine architecture, but if not your built Meteor package will be
  portable.

{{/better_markdown}}
</template>
